<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ajie825.github.io</id>
    <title>Gridea</title>
    <updated>2022-08-12T09:53:20.398Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ajie825.github.io"/>
    <link rel="self" href="https://ajie825.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ajie825.github.io/images/avatar.png</logo>
    <icon>https://ajie825.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[nginx使用常见问题]]></title>
        <id>https://ajie825.github.io/post/nginx-shi-yong-chang-jian-wen-ti/</id>
        <link href="https://ajie825.github.io/post/nginx-shi-yong-chang-jian-wen-ti/">
        </link>
        <updated>2022-08-10T03:12:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nginx多server优先级">nginx多server优先级</h2>
<pre><code class="language-bash">在开始处理一个http请求时，nginx会取出header头中的Host变量，与nginx.conf中每个server的server_name进
行匹配，以此决定由哪一个server来处理这个请求，但nginx如配置多个相同的server_name，会导致server_name
出现优先级访问冲突。
</code></pre>
<pre><code class="language-bash">1）准备nginx对应的配置文件
[root@web02 conf.d]# cat code1.conf 
server {
  listen 80;
  server_name localhost code1.oldboy.com;
  location / {
     root /code1;
     index index.html;
  }
}

[root@web02 conf.d]# cat code2.conf 
server {
  listen 80;
  server_name localhost code2.oldboy.com;
  location / {
     root /code2;
     index index.html;
  }
}

[root@web02 conf.d]# cat code3.conf 
server {
  listen 80;
  server_name localhost code3.oldboy.com;
  location / {
     root /code3;
     index index.html;
  }
}
</code></pre>
<pre><code class="language-bash">2）准备站点目录
[root@web02 conf.d]# mkdir /code{1..3} -p
[root@web02 conf.d]# for i in {1..3};do echo &quot;Code$i&quot; &gt; /code$i/index.html;done
[root@web02 conf.d]# cat /code1/index.html 
Code1
[root@web02 conf.d]# cat /code2/index.html  
Code2
[root@web02 conf.d]# cat /code3/index.html  
Code3
</code></pre>
<pre><code class="language-bash">3）检查语法，并重新加载nginx
[root@web02 conf.d]# nginx -t
nginx: [warn] conflicting server name &quot;localhost&quot; on 0.0.0.0:80, ignored
nginx: [warn] conflicting server name &quot;localhost&quot; on 0.0.0.0:80, ignored
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
# 重启Nginx
[root@Nginx ~]# systemctl restart nginx
</code></pre>
<pre><code class="language-bash">4）测试访问效果
#当用户第一次访问, 由code1.conf返回输出信息
[root@web02 ~]# curl localhost
Code 1

#此时将code1.conf修改为code5.conf后进行重载Nginx
[root@web02 conf.d]# mv code1.conf code5.conf
[root@web02 conf.d]# systemctl reload nginx

#再次访问时, 由code2.conf返回输出信息
[root@web02 ~]# curl localhost
Code 2
</code></pre>
<h3 id="优先级匹配结果">优先级匹配结果</h3>
<pre><code class="language-bash">1）首先选择所有的字符串完全匹配的server_name（完全匹配）
2）选择通配符在前面的server_name，如*.oldboy.com
3）选择通配符在后面的server_name，如oldboy.*
4）最后选择使用正则表达式匹配的server_name
5）如果全部都没有匹配到，那么将选择在listen配置项后加入[default_server]的server块
6）如果没写，那么就找到匹配listen端口的第一个Server块的配置文件
</code></pre>
<pre><code class="language-bash">当出现多个相同的server_name情况下，配置文件排序优先使用则会被调用，所以建议配置相同端口，不同域名，这样则不
会出现域名访问冲突
</code></pre>
<h2 id="nginx禁止ip直接访问">nginx禁止IP直接访问</h2>
<pre><code class="language-bash">当用户通过访问IP或者未知域名访问网站的时候，希望禁止显示任何有效内容，可以返回500错误，目前国内很多机房都要求
关闭空主机头，防止未备案的域名指向过来造成麻烦。
server {
    listen 80;
    server_name www.oldboy.com;      # 这里指定自己的域名
}
server｛
    listen 80 default_server;        # 默认优先返回
    server_name _;                   # 空主机头或IP
    return 500;                      # 返回500错误
}
</code></pre>
<pre><code class="language-bash">也可以将流量集中导入自己的网站，只要做以下跳转设置就可以
server {
    listen 80 default_server;
    return 302 https://www.oldboy.com;
}
</code></pre>
<h2 id="nginx包含文件include">nginx包含文件Include</h2>
<pre><code class="language-bash">一台服务器配置多个server网站，如果配置都写在nginx.conf主配置文件中，会导致nginx.conf主配置文件变得非常庞大
而且可读性非常的差，那么后期的维护就变得麻烦。假设现在希望快速的关闭一个站点，该怎么办？
1）如果是写在nginx.conf中，则需要手动注释，比较麻烦
2）如果是include的方式，那么仅需修改配置文件的扩展名，即可完成注释
Include包含的作用是为了简化主配置文件，便于人类可读。
</code></pre>
<h2 id="nginx路径root与alias">nginx路径root与alias</h2>
<pre><code class="language-bash">root与alias路径匹配主要区别在于nginx如果解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务
器文件上，alias是一个目录别名的定义，root则是最上层目录的定义。
root的处理结果是：root路径+location路径
alias的处理结果是：使用alias路径替换location路径
</code></pre>
<h3 id="root路径配置实例">root路径配置实例</h3>
<pre><code class="language-bash">用户访问image.oldboy.com/image/oldboy.png，实际上nginx会上/code/image/目录下找去找oldboy.png文件
1）准备配置文件
[root@web02 conf.d]# cat code2.conf 
server {
  listen 80;
  server_name image.oldboy.com;
  location /image/ {
     root /code;
  }
}
2）准备站点目录
[root@web02 conf.d]# mkdir /code/image/ -p 
[root@web02 conf.d]# cd /code/image/
[root@web02 image]# ls
oldboy.png
3）检查语法，重启nginx服务
[root@web02 conf.d]# nginx -t
[root@web02 conf.d]# systemctl reload nginx
4）域名解析，浏览器访问image.oldboy.com/image/oldboy.png可以正常访问页面
</code></pre>
<h3 id="alias路径配置实例">alias路径配置实例</h3>
<pre><code class="language-bash">用户访问image.oldboy.com/image/oldboy.png，实际上nginx会上/code目录下去找oldboy.png文件
1）准备配置文件
[root@web02 conf.d]# cat code2.conf 
server {
   listen 80;
   server_name image.oldboy.com;

   location /image/ {
       alias /code/;
   }
}
2）准备站点目录
[root@web02 conf.d]# cd /code
[root@web02 image]# ls
oldboy.png
3）检查语法并重启nginx服务
[root@web02 code]# nginx -t
[root@web02 code]# systemctl reload nginx
4）浏览器访问image.oldboy.com/image/oldboy.png可以正常访问页面
</code></pre>
<h2 id="nginx-try_file路径匹配">nginx try_file路径匹配</h2>
<pre><code class="language-bash">nginx的try_file路径匹配，按顺序检查文件是否存在
[root@web02 ~]# cat /etc/nginx/conf.d/try_file.conf
server {
    listen 80;
    server_name try.oldboy.com;
    root /code;

    location / {
        try_files $uri /404.html /index.php;
    }
}
1）检查用户请求的uri内容是否存在本地，存在则解析
2）如果请求的uri不存在，则访问对应站点目录中的404.html文件
3）最后交给index.php处理
</code></pre>
<h3 id="演示实例">演示实例</h3>
<pre><code class="language-bash">1）配置nginx的try_files
[root@web02 ~]# cd /etc/nginx/conf.d/
[root@web02 conf.d]# cat try.conf 
server {
        listen 80;
        server_name try.oldboy.com;
        root /code;
        index index.html;
        location / {
                try_files $uri @java_page;
        }
        location @java_page {
                proxy_pass http://127.0.0.1:8080;
        }
}
2）准备站点目录
[root@web02 conf.d]# echo &quot;Try-Page&quot; &gt; /code/index.html
[root@web02 conf.d]# echo &quot;Tomcat-Page&quot; &gt; /usr/share/tomcat/webapps/ROOT/index.html
3）重启nginx和检查tomcat服务
[root@web02 conf.d]# nginx -t
[root@web02 conf.d]# systemctl reload nginx
[root@web02 conf.d]# systemctl reload nginx
[root@web02 conf.d]# netstat -lnpt|grep 8080
tcp6       0      0 :::8080                 :::*                    LISTEN      946/java
4）配置域名解析并进行测试
[root@web02 conf.d]# curl http://try.oldboy.com/index.html
Try-Page
#将/code/index.html文件移走
[root@web02 conf.d]# mv /code/index.html /code/index.html_bak
#发现由tomcat返回了请求
[root@web02 conf.d]# curl http://try.oldboy.com/index.html   
Tomcat-Page
</code></pre>
<h2 id="nginx调整上传文件大小">nginx调整上传文件大小</h2>
<pre><code class="language-bash">在nginx使用过程中，上传文件的过程中，通常需要设置nginx报文大小限制，避免出现413 Request Entity Too Large
Nginx上传文件大小限制配置语法
Syntax ：client_max_body_size size；
Default：client_max_body_size 1m；
Context：http，server，location

Nginx上传文件大小限制配置示例
#也可以放入http层，全局生效
Server {
   client_max_body_size 200m;
}
</code></pre>
<h2 id="nginx优雅显示错误页面">nginx优雅显示错误页面</h2>
<pre><code class="language-bash">1）准备配置文件
[root@web02 ~]# cd /etc/nginx/conf.d/
[root@web02 conf.d]# cat node.conf
server {
  listen 80;
  server_name node.oldboy.com;
  root /code;
  
  location / {
    index index.html index.php;
  }
 
  location ~ \.php$ {
     fastcgi_pass 127.0.0.1:9000;
  }

  #如服务器返回如下错误状态码，则进行跳转，跳转至/40x.jpg
  error_page 404 403 /40x.jpg;
  #如服务器返回如下错误状态码，则进行跳转，跳转至/50x.html
  error_page 500 502 503 504 /50x.html;
  
  location = /40x.jpg {
     root /code/error_40x;
  }

  location = /50x.html {
     root /code/error_50x;  
  }
}
2）准备站点目录
[root@web02 conf.d]# mkdir /code/error_40x/ -p
[root@web02 conf.d]# cd /code/error_40x/
[root@web02 error_40x]# ls
40x.jpg
3）浏览器访问node.oldboy.com/xyz，会出现下面图片
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ajie825.github.io/post-images/1660116275337.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">注意：配置在后端web节点的error_page，跟负载均衡没有关系，用户得到的页面最终是由web节点反馈的
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[keepalived高可用]]></title>
        <id>https://ajie825.github.io/post/keepalived-gao-ke-yong/</id>
        <link href="https://ajie825.github.io/post/keepalived-gao-ke-yong/">
        </link>
        <updated>2022-08-09T05:33:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="keepalived高可用基本概述">Keepalived高可用基本概述</h2>
<h3 id="什么是高可用">什么是高可用</h3>
<pre><code class="language-bash">一般是指2台机器启动着相同的业务系统，当一台机器down了，另外一台服务器能快速的接管，对于访问的用户是无感知的。
</code></pre>
<h3 id="高可用通常使用什么软件">高可用通常使用什么软件</h3>
<pre><code class="language-bash">通过服务高可用我们选择使用keepalived软件实现。
</code></pre>
<h3 id="keepalived是如何实现高可用的">keepalived是如何实现高可用的</h3>
<pre><code class="language-bash">keepalived软件是基于VRRP协议实现的，VRRP虚拟路由冗余协议，主要用于解决单点故障问题。
</code></pre>
<h3 id="vrrp是如何诞生的vrrp的原理">VRRP是如何诞生的，VRRP的原理</h3>
<pre><code class="language-bash">比如公司的网络是通过网关转换NAT进行上网的，那如果该路由器故障了，网关无法转发报文了，此时所有人都将无法上网，这时
候怎么办呢？
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ajie825.github.io/post-images/1660025084750.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">通常做法是给路由器增加一台备节点，但问题来了？如果我们的主网关master故障了，用户是需要手动修改网关指向backup，如
果用户过多修改起来会非常的麻烦。
第一个问题：假设用户将指向都修改到backup路由器，那么master路由器如果修复好了又该怎么办？
第二个问题：假设master网关故障，我们将backup网关配置为master网关IP行不行？其实上不行，因为PC第一次是通过ARP广播
寻找到master网关的mac地址与ip地址，PC则会将master网关对应的ip与mac地址写入ARP缓存表中，那么PC第二次则会直接读取
ARP缓存表中的mac地址与ip地址，然后进行数据包的转发。此时PC转发的数据包还是会交给master，（除非PC的ARP缓存表过期，
再次发起ARP广播的时候才能正确获取backup的mac地址与对应的ip地址）。
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ajie825.github.io/post-images/1660025964485.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">如何才能做到出现故障自动转移，此时VRRP就应运而生了，我们的VRRP其实是通过软件或者硬件的形式在master和backup外面增
加一个虚拟mac地址(简称VMAC)与虚拟IP地址(简称VIP)。那么在这种情况下，PC请求VIP的时候，无论是master处理还是backup
处理，PC仅会在ARP缓存表中记录VMAC与VIP的对应关系。
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://ajie825.github.io/post-images/1660026412427.jpg" alt="" loading="lazy"></figure>
<h3 id="高可用keepalived使用场景">高可用keepalived使用场景</h3>
<pre><code class="language-bash">通常业务系统需要保证7x24不down机。比如公司内部OA系统，每天公司人员都需要使用，则不允许down机，作为业务系统来说随时
都可用
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://ajie825.github.io/post-images/1660026635053.jpg" alt="" loading="lazy"></figure>
<h3 id="高可用核心概念总结">高可用核心概念总结</h3>
<pre><code class="language-bash">1）如何确定谁是主节点谁是备用节点（投票选举？优先级？）
2）如果master故障，backup自动接管，那master恢复后会夺权吗（抢占式、非抢占式）
3）如果两台服务器都认为自己是master会出现什么问题（脑裂）
</code></pre>
<h2 id="keepalived高可用安装配置">Keepalived高可用安装配置</h2>
<pre><code class="language-bash">1）实践环境，配置实现虚拟IP转移
状态	                 IP	                          角色
节点1	               10.0.0.5                      Master
节点2	               10.0.0.6                      Backup
虚拟VIP	               10.0.0.3      
</code></pre>
<pre><code class="language-bash">2）在master与backup上分别安装keepalived
[root@lb01 ~]# yum install keepalived -y
[root@lb02 ~]# yum install keepalived -y
</code></pre>
<pre><code class="language-bash">3）配置master节点
[root@lb01 ~]# cat /etc/keepalived/keepalived.conf
global_defs {                  #全局配置
    router_id lb01             #标识身份---&gt;名称
}

vrrp_instance VI_1 {
    state MASTER               #标识角色状态
    interface ens33            #网卡绑定接口
    virtual_router_id 50       #虚拟路由id
    priority 150               #优先级
    advert_int 1               #监测间隔时间
    authentication {           #认证
        auth_type PASS         #明文密码
        auth_pass 1111
}
    virtual_ipaddress {
        10.0.0.3               #虚拟的VIP地址
    }
}
</code></pre>
<pre><code class="language-bash">4）配置backup节点
[root@lb02 ~]# cat /etc/keepalived/keepalived.conf
global_defs {
    router_id lb02
}

vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id 50
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        10.0.0.3
    }
}
</code></pre>
<pre><code class="language-bash">5）对比keepalived的master与backup配置的区别
Keepalived配置区别          Master配置	              Backup配置
route_id(唯一标识)            lb01	                    lb02
state(角色状态)	             MASTER	                    BACKUP
priority(优先级)	             150	                     100
</code></pre>
<pre><code class="language-bash">6）启动Master与Backup节点的keepalived
[root@lb01 ~]# systemctl enable keepalived
[root@lb01 ~]# systemctl start keepalived 
[root@lb02 ~]# systemctl enable keepalived
[root@lb02 ~]# systemctl start keepalived
</code></pre>
<h3 id="检查keepalived的虚拟vip地址能否漂移">检查keepalived的虚拟VIP地址能否漂移</h3>
<pre><code class="language-bash">1）在master上进行如下操作
#master存在vip地址
[root@lb01 ~]# ip addr|grep 10.0.0.3
    inet 10.0.0.3/32 scope global ens33
#停止master上的keepalived，检测vip已不存在
[root@lb01 ~]# systemctl stop keepalived
[root@lb01 ~]# ip addr|grep 10.0.0.3 
</code></pre>
<pre><code class="language-bash">2）在backup上进行如下操作
#发现VIP地址已经漂移至backup端
[root@lb02 ~]# ip addr|grep 10.0.0.3
    inet 10.0.0.3/32 scope global ens33
</code></pre>
<pre><code class="language-bash">3）此时重新启动Master上的Keepalived,会发现VIP被强行抢占
[root@lb01 ~]# systemctl start keepalived
[root@lb01 ~]# ip addr|grep 10.0.0.3     
    inet 10.0.0.3/32 scope global ens33
</code></pre>
<pre><code class="language-bash">4）通过windows的arp -a命令查看arp缓存表，验证地址漂移后是否会自动更新MAC地址。
</code></pre>
<h2 id="keepalived高可用非抢占式">Keepalived高可用非抢占式</h2>
<pre><code class="language-bash">通常master服务故障后backup会变成master，但是当master服务又恢复的时候，master会抢占VIP，这样就会发生两次切换对
业务繁忙的网站来说并不是太友好，此时我们可以配置keepalived为非抢占式。
</code></pre>
<h3 id="配置非抢占式要求">配置非抢占式要求</h3>
<pre><code class="language-bash">1）两个节点的state都必须配置为BACKUP（官方建议）
2）两个节点都在vrrp_instance中添加nopreempt参数
3）其中一个节点的优先级必须要高于另外一个节点的优先级
两台服务器启用nopreempt后，必须修改角色状态统一为BACKUP，唯一区分就是优先级。
</code></pre>
<pre><code class="language-bash">#master的配置如下：
[root@lb01 ~]# cat /etc/keepalived/keepalived.conf     
global_defs {
    router_id lb01
}

vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id 50
    priority 150
    nopreempt
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
}
    virtual_ipaddress {
        10.0.0.3
    }
[root@lb01 ~]# systemctl restart keepalived
</code></pre>
<pre><code class="language-bash">#Backup的配置如下：
[root@lb02 ~]# cat /etc/keepalived/keepalived.conf     
global_defs {
    router_id lb02
}

vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id 50
    priority 100
    nopreempt
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
}
    virtual_ipaddress {
        10.0.0.3
    }
}
[root@lb02 ~]# systemctl restart keepalived
</code></pre>
<h2 id="keepalived高可用故障脑裂">keepalived高可用故障脑裂</h2>
<pre><code class="language-bash">脑裂：指在一个高可用（HA）系统中，当联系着的两个节点断开联系时，本来为一个整体的系统，分裂为两个独立节点，这时两个节点开始争抢共享资源，结果会导致系统混乱，数据损坏。
由于某些原因，当两台keepalived高可用服务器在指定时间内，无法互相检测到对方心跳消息而各自启动故障转移功能，取得资
源及服务的所有权，而此时的两台高可用服务器都还活着并且正常工作。这样就会导致同一个服务在两端同时启动而发生冲突的严
重问题。
</code></pre>
<h3 id="产生故障脑裂的原因">产生故障脑裂的原因</h3>
<pre><code class="language-bash">1）服务器网线松动等网络故障
2）服务器硬件故障发生损坏现象而崩溃
3）主备都开启firewalld防火墙
</code></pre>
<h3 id="处理故障脑裂的方法">处理故障脑裂的方法</h3>
<pre><code class="language-bash">在备上编写检测脚本，测试如果能ping通主并且备节点还有VIP的话则认为产生了脑裂
[root@lb02 ~]# cat check_split_brain.sh 
#!/bin/sh
vip=10.0.0.3
master_ip=10.0.0.5
while true;do
    ping -c 2 -W 3 $master_ip &amp;&gt;/dev/null
    if [ $? -eq 0 -a `ip add|grep &quot;$vip&quot;|wc -l` -eq 1 ];then
        echo &quot;ha is split brain.warning.&quot;
    else
        echo &quot;ha is ok&quot;
    fi
sleep 5
done
如果发生上述闹裂，通常情况下随机kill掉一台即可
</code></pre>
<pre><code class="language-bash">如果负载均衡的nginx宕机，会导致用户请求失败，但keepalived并不会进行切换，所以需要编写一个脚本检测nginx的存活状
态，如果不存活则kill nginx和keepalived
[root@lb01 ~]# mkdir /server/scripts -p
[root@lb01 ~]# vim /server/scripts/check_web.sh 
#!/bin/sh
nginxpid=$(ps -C nginx --no-header|wc -l)

#判断Nginx是否存活,如果不存活则尝试启动Nginx
if [ $nginxpid -eq 0 ];then
        systemctl start nginx
        sleep 3
        #等待3秒后再次获取一次Nginx状态
        nginxpid=$(ps -C nginx --no-header|wc -l) 
        #再次进行判断, 如Nginx还不存活则停止Keepalived,让地址进行漂移,并退出脚本  
        if [ $nginxpid -eq 0 ];then
                systemctl stop keepalived
          fi
fi
#给脚本增加执行权限
[root@lb01 ~]# chmod +x /server/scripts/check_web.sh
</code></pre>
<pre><code class="language-bash">在master的keepalived中调用脚本，抢占式仅需要在master配置即可（如果配置为非抢占式，需要两台服务器都配置该脚本）
[root@lb01 ~]# cat /etc/keepalived/keepalived.conf
global_defs {
         router_id lb01
}

#每5秒执行一次脚本, 脚本执行内容不能超过5秒,否则会被中断再次重新运行脚本
vrrp_script check_web {
   script &quot;/server/scripts/check_web.sh&quot;
   interval 5
}

vrrp_instance VI_1 {
    nopreempt
    state BACKUP
    interface ens33
    virtual_router_id 50
    priority 150
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        10.0.0.3
    }
    
    #调用并运行该脚本
    track_script {
        check_web
    }
}
</code></pre>
<pre><code class="language-bash">公有云不支持keepalived、银行、金融、证券、国企
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx https实践]]></title>
        <id>https://ajie825.github.io/post/nginx-https-shi-jian/</id>
        <link href="https://ajie825.github.io/post/nginx-https-shi-jian/">
        </link>
        <updated>2022-08-08T09:26:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="https安全证书基本概述">HTTPS安全证书基本概述</h2>
<pre><code class="language-bash">为什么需要使用HTTPS，因为HTTP不安全。当我们使用http网站时，会遭到劫持和篡改，如果采用https协议，那么数据在传输
过程中是加密的，所以黑客无法窃取或者篡改数据报文信息，同时也避免网站传输时信息泄露。
那么我们在实现https时，需要了解ssl协议，但我们现在使用的更多的是TLS加密协议。
那么TLS是怎么保证明文消息被加密的呢？在OSI七层模型中，应用层是http协议，那么在应用层协议之下，我们的表示层，是ssl
协议所发挥作用的一层，它通过（握手、交互密钥、告警、加密）等方式，使应用层http协议没有感知的情况下做到了数据的安全
加密。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ajie825.github.io/post-images/1660007696893.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">那么在数据进行加密与解密过程中，如何确定双方的身份，此时就需要有一个权威机构来验证双方身份。那么这个权威机构则是
CA机构，那CA机构又是如何颁发证书的？
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ajie825.github.io/post-images/1660007935443.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">我们首先需要申请证书，需要进行登记，登记我是谁，我是什么组织，我想做什么，到了登记机构在通过CSR发给CA，CA中心会
生成一对公钥和私钥，那么公钥会在CA证书链中保存，公钥和私钥证书订阅人拿到后，会将其部署在web服务器上。
1）当浏览器访问我们的https站点时，它会去请求我们的证书
2）nginx服务器会将我们的公钥证书发给浏览器
3）浏览器会去验证我们的证书是否是合法和有效的
4）CA机构会将过期的证书放置在CRL服务器，那么CRL服务的验证效率是非常差的，所以CA又推出了OCSP响应程序，OCSP响应
程序可以查询指定的一个证书是否过期，所以浏览器可以直接查询OCSP响应程序，但OCSP响应程序性能还不是很高
5）nginx会有一个OCSP的开关，当我们开启后，nginx会主动上OCSP上查询，这样大量的客户端直接从nginx获取，证书是否有
效。
</code></pre>
<pre><code class="language-bash">那么证书究竟是怎样组成的呢，接下来我们看一下证书有哪几种类型？
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://ajie825.github.io/post-images/1660009143282.jpg" alt="" loading="lazy"></figure>
<h3 id="https证书购买选择">HTTPS证书购买选择</h3>
<pre><code class="language-bash">保护1个域名 www
保护5个域名 www  images  cdn  test  m
通配符域名  *.oldboy.com
</code></pre>
<h3 id="https注意事项">HTTPS注意事项</h3>
<pre><code class="language-bash">HTTPS不支持续费，证书到期需重新申请并进行替换
HTTPS不支持三级域名解析，如test.m.oldboy.com
HTTPS显示绿色，说明整个网站的url都是https的
HTTPS显示黄色，因为网站代码中包含http的不安全连接
HTTPS显示红色，要么证书是假的，要么证书过期
</code></pre>
<h2 id="nginx单台实现https实战">nginx单台实现HTTPS实战</h2>
<pre><code class="language-bash">1）环境准备
#nginx必须有ssl模块
[root@web01 ~]# nginx -V
--with-http_ssl_module
#创建存放ssl证书的路径
[root@web01 ~]# mkdir -p /etc/nginx/ssl_key
[root@web01 ~]# cd /etc/nginx/ssl_key/
</code></pre>
<pre><code class="language-bash">2）使用openssl命令充当CA权威机构创建证书（生产不使用此方式生成证书，不被互联网认可的黑户证书）
[root@Nginx ssh_key]# openssl genrsa -idea -out server.key 2048
Generating RSA private key, 2048 bit long modulus
.....+++
#记住配置密码, 我这里是1234
Enter pass phrase for server.key:
Verifying - Enter pass phrase for server.key:
</code></pre>
<pre><code class="language-bash">3）生成自签证书，同时去掉私钥的密码
[root@Nginx ssl_key]# openssl req -days 36500 -x509 \
-sha256 -nodes -newkey rsa:2048 -keyout server.key -out server.crt
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:WH
Locality Name (eg, city) [Default City]:WH
Organization Name (eg, company) [Default Company Ltd]:edu    
Organizational Unit Name (eg, section) []:SA
Common Name (eg, your name or your servers hostname) []:bgx
Email Address []:bgx@foxmail.com
# req  --&gt;用于创建新的证书
# new  --&gt;表示创建的是新证书
# x509 --&gt;表示定义证书的格式为标准格式
# key  --&gt;表示调用的私钥文件信息
# out  --&gt;表示输出证书文件信息
# days --&gt;表示证书的有效期
[root@web01 ssl_key]# ls
server.crt  server.key
</code></pre>
<pre><code class="language-bash">4）证书申请完成后需要了解nginx如何配置HTTPS
#启动ssl功能
Syntax : ssl on | off;
Default: ssl off;
Context: http, server
#证书文件
Syntax : ssl_certificate file;
Default: —
Context: http, server
#私钥文件
Syntax : ssl_certificate_key file;
Default: —
Context: http, server
</code></pre>
<pre><code class="language-bash">5）nginx配置https实例
[root@web01 ~]# cd /etc/nginx/conf.d/
[root@web01 conf.d]# cat ssl.conf 
server {
    listen 443 ssl;
    server_name s.oldboy.com;
    ssl_certificate   ssl_key/server.crt;
    ssl_certificate_key  ssl_key/server.key;
    location / {
        root /code;
        index index.html;
    }
}
#准备对应的站点目录, 并重启Nginx服务
[root@web01 conf.d]# mkdir -p /code
[root@web01 conf.d]# echo &quot;Https&quot; &gt; /code/index.html
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">6）浏览器输入https://s.oldboy.com访问, 由于该证书非第三方权威机构颁发，而是我们自己签发的，所以浏览器会警告
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://ajie825.github.io/post-images/1660011504588.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">7）如果用户忘记在浏览器输入https://那么将不会跳转至https，建议配置将用户访问http请求强制跳转https----生产建议
[root@web01 conf.d]# cat ssl.conf 
server {
    listen 443 ssl;
    server_name s.oldboy.com;
    ssl_certificate   ssl_key/server.crt;
    ssl_certificate_key  ssl_key/server.key;
    location / {
        root /code;
        index index.html;
    }
}
server {
        listen 80;
        server_name s.oldboy.com;
        rewrite ^(.*) https://$server_name$1 redirect;  #rewrite跳转方式
        #return 302 https://$server_name$request_uri;   #return跳转方式   
}
</code></pre>
<h2 id="nginx集群实现https实践">Nginx集群实现HTTPS实践</h2>
<h3 id="nginx负载均衡nginx-web配置https安全">Nginx负载均衡+Nginx WEB配置HTTPS安全</h3>
<figure data-type="image" tabindex="5"><img src="https://ajie825.github.io/post-images/1660013326588.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">1）环境准备
主机名           外网IP(NAT)         内网IP(LAN)           角色
lb01             10.0.0.5	         172.16.1.5	        nginx-proxy
web01            10.0.0.7	         172.16.1.7	        nginx-web01
web02            10.0.0.8	         172.16.1.8	        nginx-web02
</code></pre>
<pre><code class="language-bash">2）配置后端两台web节点监听80端口，如已配置则无需修改
#web01的配置
[root@web01 conf.d]# cat ssl.conf 
server {
  listen 80;
  server_name s.oldboy.com;

  location / {
     root /code;
     index index.html;
  }
}
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl reload nginx
[root@web01 conf.d]# echo &quot;Web01 Https&quot; &gt; /code/index.html

#web02的配置
[root@web02 conf.d]# cat ssl.conf 
server {
  listen 80;
  server_name s.oldboy.com;

  location / {
     root /code;
     index index.html;
  }
}
[root@web02 conf.d]# nginx -t
[root@web02 conf.d]# systemctl reload nginx
[root@web02 conf.d]# echo &quot;Web02 Https&quot; &gt; /code/index.html 
</code></pre>
<pre><code class="language-bash">3）配置负载均衡，管理我们的ssl证书，并进行配置nginx
[root@lb01 ~]# scp -rp 10.0.0.7:/etc/nginx/ssl_key /etc/nginx 
[root@lb01 conf.d]# cat upstream.conf 
# 定义后端资源池
upstream site {
    server 172.16.1.7:80 max_fails=2 fail_timeout=10s;
    server 172.16.1.8:80 max_fails=2 fail_timeout=10s;
}
[root@lb01 conf.d]# cat proxy_ssl.conf 
# https配置
server {
    listen 443 ssl;
    server_name s.oldboy.com;
   
    ssl_certificate  ssl_key/server.crt;
    ssl_certificate_key  ssl_key/server.key;
    location / {
        proxy_pass http://site;
        include proxy_params;
    }
}
# 用户http请求跳转至https
server {
    listen 80;
    server_name s.oldboy.com;
    return 302 https://$server_name$request_uri;
}
[root@lb01 conf.d]# nginx -t
[root@lb01 conf.d]# systemctl restart nginx
</code></pre>
<h3 id="将wordpress-wecenter-phpadmin在负载均衡添加https">将WordPress、WeCenter、phpAdmin在负载均衡添加HTTPS</h3>
<pre><code class="language-bash">#配置文件都类似，只需要更改域名即可
[root@lb01 conf.d]# cat proxy_blog.conf 
# https配置
server {
    listen 443 ssl;
    server_name blog.oldboy.com;
   
    ssl_certificate  ssl_key/server.crt;
    ssl_certificate_key  ssl_key/server.key;
    location / {
        proxy_pass http://site;
        include proxy_params;
    }
}
# 用户http请求跳转至https
server {
    listen 80;
    server_name blog.oldboy.com;
    return 302 https://$server_name$request_uri;
}
[root@lb01 conf.d]# nginx -t
[root@lb01 conf.d]# systemctl restart nginx
</code></pre>
<pre><code class="language-bash">#问题
当负载均衡配置为HTTPS时，后端的php-fpm节点为HTTP，WordPress、WeCenter访问的页面会出现破图，phpAdmin无法进行登
录，需要在后端web节点配置fastcgi_param HTTPS on参数
[root@web01 conf.d]# cat blog.oldboy.com.conf 
server {
        listen 80;
        server_name blog.oldboy.com;
        root /code/wordpress;
        client_max_body_size 100m;
        location / {
                index index.php index.html;
        }

        location ~ \.php$ {
                fastcgi_pass 127.0.0.1:9000;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param HTTPS on; 
                include fastcgi_params;
        }
}
[root@web01 conf.d]# nginx -t 
[root@web01 conf.d]# systemctl restart nginx
</code></pre>
<h3 id="ssl优化相关的参数">SSL优化相关的参数</h3>
<pre><code class="language-bash">ssl_session_cache shared:SSL:10m;        #在建立完ssl握手后如果断开连接，在session_timeout时间内再次连接，是不需要再次建立握手，可以复用之前的连接
ssl_session_timeout 1440m;               #ssl连接断开后的超时时间
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;     #使用的TLS版本协议
ssl_prefer_server_ciphers on;            #Nginx决定使用哪些协议与浏览器进行通讯
ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密套件
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx rewrite重写]]></title>
        <id>https://ajie825.github.io/post/nginx-rewrite-chong-xie/</id>
        <link href="https://ajie825.github.io/post/nginx-rewrite-chong-xie/">
        </link>
        <updated>2022-08-08T02:00:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="rewrite基本概述">rewrite基本概述</h2>
<h3 id="什么是rewrite">什么是rewrite</h3>
<pre><code class="language-bash">rewrite主要实现url地址重写，以及地址重定向，就是将用户请求web服务器的地址重新定向到其他url的过程。
</code></pre>
<h3 id="rewrite使用场景">rewrite使用场景</h3>
<pre><code class="language-bash">1）地址跳转，用户访问www.oldboy.com/class这个url时，将其定向至一个新的域名class.oldboy.com
2）协议跳转，用户通过http协议请求网站时，将其重新跳转至https协议方式
3）伪静态，将动态页面显示为静态页面的一种技术方式，便于搜索引擎的录入，同时减少动态URL地址对外暴露过多的参数，
提升更高的安全性。
4）搜索引擎，SEO优化依赖于url路径，好记的url便于支持搜索引擎录入
</code></pre>
<h3 id="rewrite配置语法">rewrite配置语法</h3>
<pre><code class="language-bash">#rewrite表达式可以应用在server,location, if标签下
Syntax: rewrite regex replacement [flag];
Default: --
Context: server, location, if
#用于切换维护页面场景
#rewrite ^(.*)$ /page/wh.html break;
</code></pre>
<h2 id="rewrite标记flag">rewrite标记Flag</h2>
<pre><code class="language-bash">rewrite指令根据表达式来重定向URL，或者修改URI字符串。
每行rewrite指令最后跟一个flag标记，支持的flag标记有如下所示：
flag	                     作用
last	    本条规则匹配完成后，停止匹配，不在匹配后面的规则
break	    本条规则匹配完成后，停止匹配，不在匹配后面的规则
redirect	返回302临时重定向, 地址栏会显示跳转后的地址
permanent	返回301永久重定向, 地址栏会显示跳转后的地址
</code></pre>
<h3 id="last与break区别对比示例">last与break区别对比示例</h3>
<pre><code class="language-bash">1）编写nginx配置文件
[root@web01 ~]# cd /etc/nginx/conf.d/
[root@web01 conf.d]# cat rewrite.conf 
server {
    listen 80;
    server_name rewrite.oldboy.com;
    root /code;
    location ~ ^/break {
        rewrite ^/break /test/ break;
    }
    location ~ ^/last {
        rewrite ^/last /test/ last;
    }
    location  /test/ {
        default_type application/json;
        return 200 'ok';
    }
}
#重载nginx服务
[root@web01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">2）配置域名解析，使用浏览器访问/break测试
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ajie825.github.io/post-images/1659926590315.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">3）使用浏览器访问/last测试
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ajie825.github.io/post-images/1659926973235.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">4）last和break都是一个作用，都是表示停止rewrite规则，那last和break区别在哪？
break匹配到规则，会去本地路径目录中寻找对应的请求文件，如果文件不存在，则返回404，如果文件存
在，则有后面的location匹配。
last匹配到规则，也会去本地路径目录中寻找对应的请求文件，如果文件不存在会对其所在的server{...}
标签重新发起请求。
所以，在访问/break和/last请求时，虽然对应的请求目录/test都是不存在的，理论上都应该返回404，
但是实际请求/last的时候，会有后面location所匹配到的结果返回，如果last匹配不到location的结
果则在返回错误。
</code></pre>
<h3 id="redirect与permanent区别对比示例">redirect与permanent区别对比示例</h3>
<pre><code class="language-bash">1）编写nginx配置文件
[root@web01 conf.d]# cat rewrite.conf 
server {
    listen 80;
    server_name rewrite.oldboy.com;
    root /code;
    location ~ ^/bgx {
        rewrite ^(.*)$ https://www.xuliangwei.com redirect;
       # rewrite ^(.*)$ https://www.xuliangwei.com permanent;
        #return 301 http://kt.xuliangwei.com;
        #return 302 http://kt.xuliangwei.com;
    }
}
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">2）通过浏览器访问，redirect会进行跳转
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://ajie825.github.io/post-images/1659938414994.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">3）停止nginx，然后再次访问测试redirect
[root@web01 conf.d]# systemctl stop nginx
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://ajie825.github.io/post-images/1659938529925.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">4）通过浏览器访问，permanent会进行301跳转
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://ajie825.github.io/post-images/1659938614507.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">5）停止nginx，然后再次访问测试permanent
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://ajie825.github.io/post-images/1659938704041.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">6）redirect和permanent都是一个跳转，那redirect和permanent区别在哪？实现https
redirect每次请求都会询问服务器，如果当服务器不可用时，则会跳转失败。
permanent第一次请求会询问服务器，浏览器会记录跳转地址，第二次则不再询问服务器，直接通过浏览器缓存的地址跳转。
</code></pre>
<h2 id="rewrite规则实践">rewrite规则实践</h2>
<pre><code class="language-bash">例1:用户访问/abc/1.html实际上真实访问是/ccc/bbb/2.html
#http://rewrite.oldboy.com/abc/1.html ==&gt; http://rewrite.oldboy.com/ccc/bbb/2.html
1）nginx跳转配置
[root@web01 conf.d]# cat ccbb.conf 
server {
    listen 80;
    server_name rewrite.oldboy.com;
    
    location / {
        root /code;
        index index.html;
    }
    #匹配/abc开头的任何字符都跳转到/code/ccc/bbb/2.html
    location /abc {
        rewrite (.*) /ccc/bbb/2.html redirect;
        #return 302 /ccc/bbb/2.html;
    }
}
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl reload nginx
2）准备真实的访问路径
[root@web01 conf.d]# mkdir /code/ccc/bbb -p
[root@web01 conf.d]# echo &quot;ccc_bbb_2&quot; &gt; /code/ccc/bbb/2.html
</code></pre>
<pre><code class="language-bash">例2:用户访问/2018/ccc/bbb/2.html实际上真实访问是/2014/ccc/bbb/2.html
#http://rewrite.oldboy.com/2018/ccc/bbb/2.html ==&gt; http://rewrite.oldboy.com/2014/ccc/bbb/2.html
1）nginx跳转配置
[root@web01 conf.d]# cat ccbb.conf 
server {
    listen 80;
    server_name rewrite.oldboy.com;
    location / {
        root /code;
        index index.html;
    }
    location /2018 {
        rewrite ^/2018/(.*)$ /2014/$1 redirect;
    }
}
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl reload nginx
2）准备真实的访问路径
[root@web01 conf.d]# mkdir /code/2014/ccc/bbb -p
[root@web01 conf.d]# echo &quot;2014_ccc_bbb_2&quot; &gt; /code/2014/ccc/bbb/2.html
</code></pre>
<pre><code class="language-bash">例3：用户访问/test目录下任何内容，实际上真实访问的是http://www.jd.com
location /test {
       rewrite (.*) http://www.jd.com redirect;
}
</code></pre>
<pre><code class="language-bash">例4:用户访问course-11-22-33.html实际上真实访问是/course/11/22/33/course_33.html
#http://rewrite.oldboy.com/course-11-22-33.html ==&gt; http:/rewrite.oldboy.com/course/11/22/33/course_33.html  
1）nginx跳转配置
[root@web01 conf.d]# cat ccbb.conf 
server {
  listen 80;
  server_name rewrite.oldboy.com;
  root /code;
  index index.html;
 
  location / {
    # 灵活
    rewrite ^/course-(.*)-(.*)-(.*).html$ /course/$1/$2/$3/course_$3.html redirect;
    # 固定
    rewrite ^/course-(.*) /course/11/22/33/course_33.html redirect;
   }        
}
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl restart nginx
2）准备真实的访问路径
[root@web01 conf.d]# mkdir /code/course/11/22/33/ -p
[root@web01 conf.d]# echo &quot;Curl docs.etiantian.org&quot; &gt; /code/course/11/22/33/course_33.html
</code></pre>
<pre><code class="language-bash">例5:将http请求，跳转至https
server {
        listen 80;
        server_name rewrite.oldboy.com;
        rewrite ^(.*) https://$server_name$1 redirect;
        #return 302 https://$server_name$request_uri;
}
server {
    listen 443;
    server_name rewrite.oldboy.com;
    ssl on;
}
</code></pre>
<h2 id="rewrite规则补充">Rewrite规则补充</h2>
<h3 id="rewrite优先级">rewrite优先级</h3>
<pre><code class="language-bash">1）先执行server块的rewrite指令
2）其次执行location匹配规则
3）最后执行location中的rewrite
</code></pre>
<h3 id="rewrite常用变量在匹配过程中可以引用一些nginx的全局变量">Rewrite常用变量，在匹配过程中可以引用一些Nginx的全局变量</h3>
<pre><code class="language-bash">$server_name 当前用户请求的域名
$request_filename 当前请求的文件路径名（带网站的主目录/code/images/test.jpg）
$request_uri 当前请求的文件路径名（不带网站的主目录/images/test.jpg）
$scheme用的协议，比如http或者https
</code></pre>
<h3 id="如何优雅的书写rewrite规则">如何优雅的书写Rewrite规则</h3>
<pre><code class="language-bash">server {
    listen 80;
    server_name www.oldboyedu.com oldboyedu.com;
    if ($http_host = oldboyedu.com){
        rewrite (.*) http://www.nginx.org$1;
    }
}
#推荐的书写格式
server {
    listen 80;
    server_name oldboyedu.com;
    rewrite ^ http://www.oldboyedu.com$request_uri;
}
server {
    listen 80;
    server_name www.oldboyedu.com;
}

rewrite       正则          真实的文件          flag
return	   http-&gt;https    return状态码   跳转后的地址(可以使用变量)
rewrite ^(.*)$ https://$server_name$1 redirect;
return 302 https://$server_name$request_uri;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx动静分离]]></title>
        <id>https://ajie825.github.io/post/nginx-dong-jing-fen-li/</id>
        <link href="https://ajie825.github.io/post/nginx-dong-jing-fen-li/">
        </link>
        <updated>2022-08-06T06:18:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nginx动静分离基本概述">nginx动静分离基本概述</h2>
<pre><code class="language-bash">动静分离，通过中间件将动态请求和静态请求进行分离。
为什么要通过中间件将动态请求和静态请求进行分离？减少不必要的请求消耗，同时能减少请求的延时。
动静分离好处：动静分离后，即使动态服务不可用，但静态资源不会受到影响。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ajie825.github.io/post-images/1659767066290.jpg" alt="" loading="lazy"></figure>
<h2 id="nginx动静分离场景实践">nginx动静分离场景实践</h2>
<pre><code class="language-bash">demo不代表生产操作，负载均衡不需要配置
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ajie825.github.io/post-images/1659767547924.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">1）环境准备
系统	      服务	        服务	              地址
CentOS7    负载均衡	     Nginx Proxy	       10.0.0.5
CentOS7    静态资源	     Nginx Static	       10.0.0.7
CentOS7    动态资源	     Tomcat Server	       10.0.0.8
</code></pre>
<pre><code class="language-bash">2）在10.0.0.7服务器配置静态资源
[root@web01 ~]# cd /etc/nginx/conf.d/
[root@web01 conf.d]# cat ds_oldboy.conf 
server{
        listen 80;
        server_name ds.oldboy.com;
        root /soft/code;
        index index.html;
        location ~* .*\.(png|jpg|gif)$ {
                root /soft/code/images;
        }
}
#准备目录，以及相关静态图片
[root@web01 conf.d]# mkdir /soft/code/images -p
[root@web01 conf.d]# wget -O /soft/code/images/nginx.png http://nginx.org/nginx.png
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">3）在10.0.0.8服务器配置动态资源
[root@web02 ~]# yum install -y tomcat
[root@web02 ~]# mkdir /usr/share/tomcat/webapps/ROOT
[root@web02 ~]# vim /usr/share/tomcat/webapps/ROOT/java_test.jsp
&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;HTML&gt;
    &lt;HEAD&gt;
        &lt;TITLE&gt;JSP Test Page&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;
      &lt;%
        Random rand = new Random();
        out.println(&quot;&lt;h1&gt;Random number:&lt;/h1&gt;&quot;);
        out.println(rand.nextInt(99)+100);
      %&gt;
      %    &lt;/BODY&gt;
      %    &lt;/HTML&gt;
#重启tomcat
[root@web02 ~]# systemctl start tomcat
[root@web02 ~]# systemctl enable tomcat
</code></pre>
<pre><code class="language-bash">4）在负载均衡10.0.0.5配置调度，实现访问jsp和png
[root@lb01 conf.d]# cat proxy_ds.conf 
upstream static {
        server 10.0.0.7:80;
}
upstream java {
        server 10.0.0.8:8080;
}
server {
        listen 80;
        server_name ds.oldboy.com;
        location / {
                root /soft/code;
                index index.html;
        }
        location ~ .*\.(png|jpg|gif)$ {
                proxy_pass http://static;
                include proxy_params;
        }
        location  ~ .*\.jsp$ {
                proxy_pass http://java;
                include proxy_params;
        }
}
[root@lb01 conf.d]# systemctl restart nginx
</code></pre>
<pre><code class="language-bash">5）配置域名解析，通过负载测试访问静态资源ds.oldboy.com/java_test.jsp/nginx.png
10.0.0.5 web.oldboy.com node.oldboy.com php.oldboy.com ds.oldboy.com
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://ajie825.github.io/post-images/1659772644058.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">6）通过负载测试访问动态资源ds.oldboy.com/java_test.jsp
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://ajie825.github.io/post-images/1659772891973.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">7）在负载均衡10.0.0.5上整合动态和静态资源的html文件
[root@lb01 conf.d]# mkdir /soft/code -p
[root@lb01 conf.d]# cat /soft/code/index.html
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;测试ajax和跨域访问&lt;/title&gt;
        &lt;script src=&quot;http://libs.baidu.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function(){
        $.ajax({
        type: &quot;GET&quot;,
        url: &quot;http://ds.oldboy.com/java_test.jsp&quot;,
        success: function(data) {
                $(&quot;#get_data&quot;).html(data)
        },
        error: function() {
                alert(&quot;fail!!,请刷新再试!&quot;);
        }
        });
});
&lt;/script&gt;
        &lt;body&gt;
                &lt;h1&gt;测试动静分离&lt;/h1&gt;
                &lt;img src=&quot;http://ds.oldboy.com/nginx.png&quot;&gt;
                &lt;div id=&quot;get_data&quot;&gt;&lt;/div&gt;
        &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://ajie825.github.io/post-images/1659773642365.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">8）当停止静态资源的Nginx后，会发现静态内容无法访问，动态内容依旧运行正常
[root@web01 conf.d]# systemctl stop nginx
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://ajie825.github.io/post-images/1659775119611.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">9） 当停止动态资源的Tomcat后，静态内容依旧能正常访问，动态内容将不会被请求到
[root@web02 ~]# systemctl stop tomcat
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://ajie825.github.io/post-images/1659776845822.jpg" alt="" loading="lazy"></figure>
<h2 id="nginx资源分离场景实践">nginx资源分离场景实践</h2>
<h3 id="nginx通过负载均衡实现手机与pc调度至不同的后端节点应用案例">nginx通过负载均衡实现手机与PC调度至不同的后端节点应用案例</h3>
<pre><code class="language-bash">1）根据iphone、安卓、pc跳转不同的页面环境规划
系统版本         主机角色	               外网IP          内网IP	      提供端口
CentOS7.5       负载均衡	                  10.0.0.5      172.16.1.5          80
CentOS7.5       提供Android页面           	            172.16.1.7         9090
CentOS7.5       提供Iphone页面	     	                172.16.1.7         9091
CentOS7.5       提供pc页面		                        172.16.1.7         9092
</code></pre>
<pre><code class="language-bash">2）后端web节点的nginx配置
[root@web01 conf.d]# cat sj.conf 
server {
    listen 9090;
    location / {
        root /code/android;
        index index.html;
    }
}
server {
    listen 9091;
    location / {
        root /code/iphone;
        index index.html;
    }
}
server {
    listen 9092;
    location / {
        root /code/pc;
        index index.html;
    }
}
</code></pre>
<pre><code class="language-bash">3）为后端web节点配置对应的网站目录以及代码
[root@web01 conf.d]# mkdir -p /code/{android,iphone,pc}
[root@web01 conf.d]# echo &quot;PC&quot; &gt; /code/pc/index.html 
[root@web01 conf.d]# echo &quot;Iphone&quot; &gt; /code/iphone/index.html
[root@web01 conf.d]# echo &quot;Android&quot; &gt; /code/android/index.html
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">4）配置负载均衡服务，根据不同的浏览器调度到不同的资源池
[root@lb01 conf.d]# cat sj_proxy.conf 
upstream iphone {
    server 172.16.1.7:9091;
}
upstream android {
    server 172.16.1.7:9090;
}
upstream pc {
    server 172.16.1.7:9092;
}
server {
    listen 80;
    server_name sj.oldboy.com;
    location / {
    
    #默认跳转至pc站点
    proxy_pass http://pc;
    include proxy_params;
    
        #如果客户端是Iphone则跳转到iphone的资源池
        if ($http_user_agent ~* &quot;Iphone&quot;) {
            proxy_pass http://iphone;
        }
    
        #如果客户端是Android则跳转到android的资源池
        if ($http_user_agent ~* &quot;Android&quot;){
            proxy_pass http://android;
        }
    
        #如果客户端是IE浏览器，则返回403错误。
        if ($http_user_agent ~* &quot;msie&quot;){
            return 403;
        }
    }
}
[root@lb01 conf.d]# nginx -t
root@lb01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">5）配置域名解析，直接使用浏览器访问，返回默认的结果
10.0.0.5 web.oldboy.com ds.oldboy.com sj.oldboy.com
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://ajie825.github.io/post-images/1659779257835.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">6）如果通过android设备访问，效果如下
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://ajie825.github.io/post-images/1659779447149.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">7）如果通过Iphone设备访问，效果如下
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://ajie825.github.io/post-images/1659779528227.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">#实际生产中的配置
server {
        listen 80;
        server_name   www.oldboy.com;
        if ($http_user_agent ~* &quot;Android|Iphone&quot;) {
                rewrite ^/$ https://sj.oldboy.com redirect;
        }       
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx四层负载均衡]]></title>
        <id>https://ajie825.github.io/post/nginx-si-ceng-fu-zai-jun-heng/</id>
        <link href="https://ajie825.github.io/post/nginx-si-ceng-fu-zai-jun-heng/">
        </link>
        <updated>2022-08-05T09:44:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nginx四层负载均衡基本概述">nginx四层负载均衡基本概述</h2>
<h3 id="什么是四层负载均衡">什么是四层负载均衡</h3>
<pre><code class="language-bash">四层负载均衡基于传输层协议包来封装的（如：TCP/IP），那我们前面使用到的七层是指应用层，它的组装在四层基础之上，
无论四层还是七层都是指OSI网络模型。
</code></pre>
<h3 id="四层负载均衡应用场景">四层负载均衡应用场景</h3>
<pre><code class="language-bash">1）四层+七层来作负载均衡，4层可以保证7层负载均衡的高可用性。如nginx就无法保证自己的服务高可用，需要依赖lvs或者
keepalive来实现。
2）如tcp协议的负载均衡，有些请求是TCP协议的（如mysql、ssh）、或者说这些请求只需要使用4层进行端口的转发就可以了，
所以使用4层负载均衡（如mysql读的负载均衡、端口映射、端口转发）。
3）四层+七层构建大规模集群架构使用场景
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ajie825.github.io/post-images/1659754980295.jpg" alt="" loading="lazy"></figure>
<h3 id="四层负载均衡总结">四层负载均衡总结</h3>
<pre><code class="language-bash">1）四层负载均衡仅能转发TCP/IP协议、UDP协议，通常用来转发端口，如tcp/3306，tcp/22，udp/53。
2）四层负载均衡可以用来解决七层负载均衡的端口限制问题（七层负载均衡最大使用65535个端口号）。
3）可以用来解决七层负载均衡的高可用问题（多台后端七层负载均衡能同时的使用）。
4）四层的转发效率比七层的高的多，但仅支持TCP/IP协议，不支持HTTP或者HTTPS协议。
</code></pre>
<h2 id="nginx四层负载均衡场景实践">nginx四层负载均衡场景实践</h2>
<pre><code class="language-bash">#nginx四层负载均衡配置语法
stream {
    upstream backend {
        hash $remote_addr consistent;
        server backend1.example.com:12345 weight=5;
        server 127.0.0.1:12345 max_fails=3 fail_timeout=30s;
        server unix:/tmp/backend3;
    }
    server {
        listen 12345;
        proxy_connect_timeout 1s;
        proxy_timeout 3s;
        proxy_pass backend;
    }
}
</code></pre>
<h3 id="nginx四层负载均衡实战一">nginx四层负载均衡实战一</h3>
<pre><code class="language-bash">1）环境准备
角色             外网IP              内网IP                 主机名
lb-4             10.0.0.3           172.16.1.3             lb4-01
lb-7             10.0.0.5	        172.16.1.5             lb01
lb-7             10.0.0.6	        172.16.1.6             lb02
nfs                                 172.16.1.31            nfs
mysql(redis)                        172.16.1.51            mysql
web01            10.0.0.7           172.16.1.7             web01
web02            10.0.0.8           172.16.1.8             web02
</code></pre>
<pre><code class="language-bash">2）在lb02上面安装nginx
[root@lb02 ~]# cat /etc/yum.repos.d/nginx.repo 
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1
[root@lb02 ~]# yum install nginx -y
</code></pre>
<pre><code class="language-bash">3）在lb02上面拷贝lb01的所有nginx相关配置即可
[root@lb02 ~]# scp -rp root@172.16.1.5:/etc/nginx /etc/
</code></pre>
<pre><code class="language-bash">4）启动nginx
[root@lb02 conf.d]# nginx -t
[root@lb02 conf.d]# systemctl start nginx
[root@lb02 conf.d]# systemctl enable nginx
注意：
如果wecenter报500、502的错误，需要在php.ini的配置文件中修改如下
session.auto_start = 0
</code></pre>
<pre><code class="language-bash">5）配置nginx四层负载均衡
#安装nginx
[root@lb4-01 ~]# cat /etc/yum.repos.d/nginx.repo 
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1
[root@lb4-01 ~]# yum install nginx -y
</code></pre>
<pre><code class="language-bash">#修改nginx配置文件
[root@lb4-01 ~]# vim /etc/nginx/nginx.conf
events {
    ....
}
# 在events层下面，http层上面配置include
include /etc/nginx/conf.c/*.conf;

http {
	.....
}
</code></pre>
<pre><code class="language-bash">#创建存放四层负载均衡配置的目录并编写四层代理配置
[root@lb4-01 conf.c]# rm -f /etc/nginx/conf.d/default.conf   #删除http的80端口
[root@lb4-01 ~]# mkdir /etc/nginx/conf.c
[root@lb4-01 ~]# cd /etc/nginx/conf.c
[root@lb4-01 conf.c]# cat lb_domain.conf 
stream {
    upstream lb {
        server 172.16.1.5:80 weight=5 max_fails=3 fail_timeout=30s;
        server 172.16.1.6:80 weight=5 max_fails=3 fail_timeout=30s;
    }

    server {
        listen 80;
        proxy_connect_timeout 3s;
        proxy_timeout 3s;
        proxy_pass lb;
    }
}
</code></pre>
<pre><code class="language-bash">#重载服务
[root@lb4-01 conf.c]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@lb4-01 conf.c]# systemctl restart nginx
[root@lb4-01 conf.c]# systemctl enable nginx
</code></pre>
<pre><code class="language-bash">#nginx四层负载均衡记录日志
[root@lb4-01 ~]# cat /etc/nginx/conf.c/lb_domain.conf 
stream {
log_format  proxy '$remote_addr $remote_port - [$time_local] $status $protocol '
                  '&quot;$upstream_addr&quot; &quot;$upstream_bytes_sent&quot; &quot;$upstream_connect_time&quot;' ;
access_log /var/log/nginx/proxy.log proxy;
}
</code></pre>
<pre><code class="language-bash">#日志展示效果
10.0.0.1 59129 - [23/Jan/2019:12:11:40 +0800] 200 TCP &quot;172.16.1.5:80&quot; &quot;0&quot; &quot;0.000&quot;
10.0.0.1 59124 - [23/Jan/2019:12:11:41 +0800] 200 TCP &quot;172.16.1.6:80&quot; &quot;1298&quot; &quot;0.000&quot;
10.0.0.1 59145 - [23/Jan/2019:12:11:44 +0800] 200 TCP &quot;172.16.1.6:80&quot; &quot;1316&quot; &quot;0.001&quot;
10.0.0.1 59598 - [23/Jan/2019:12:22:03 +0800] 200 TCP &quot;10.0.0.7:22&quot; &quot;2213&quot; &quot;0.001&quot;
10.0.0.1 59672 - [23/Jan/2019:12:23:51 +0800] 200 TCP &quot;10.0.0.7:22&quot; &quot;2893&quot; &quot;0.001&quot;
10.0.0.1 59698 - [23/Jan/2019:12:26:43 +0800] 200 TCP &quot;10.0.0.7:22&quot; &quot;3309&quot; &quot;0.000&quot;
</code></pre>
<h3 id="nginx四层负载均衡实战二">nginx四层负载均衡实战二</h3>
<pre><code class="language-bash">1）通过访问负载均衡的5555端口，实际是后端的web01的22端口在提供服务。
2）通过访问负载均衡的6666端口，实际是后端的mysql的3306端口在提供服务。
</code></pre>
<pre><code class="language-bash"># 编写四层代理配置
[root@lb4-01 ~]# cd /etc/nginx/conf.c/
[root@lb4-01 conf.c]# cat stream.conf 
stream {
#定义日志的格式
log_format  proxy '$remote_addr -  [$time_local]  $status $protocol'
                  '&quot;$upstream_addr&quot; &quot;$upstream_bytes_sent&quot; &quot;$upstream_connect_time&quot;' ;
#调用日志，使用proxy格式
access_log /var/log/nginx/tcp_proxy.log proxy;
#定义虚拟资源池
upstream ssh {
    server 172.16.1.7:22;
}
upstream mysql {
    server 172.16.1.51:3306;
}
#调用虚拟资源池
server {
    listen 5555;
    proxy_connect_timeout 1s;
    proxy_timeout 300s;
    proxy_pass ssh;
}
server {
    listen 6666;
    proxy_connect_timeout 1s;
    proxy_timeout 300s;
    proxy_pass mysql;
}
}
[root@lb01 conf.c]# systemctl restart nginx
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx负载均衡（二）]]></title>
        <id>https://ajie825.github.io/post/nginx-fu-zai-jun-heng-er/</id>
        <link href="https://ajie825.github.io/post/nginx-fu-zai-jun-heng-er/">
        </link>
        <updated>2022-08-05T02:07:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nginx负载均衡调度算法">nginx负载均衡调度算法</h2>
<pre><code class="language-bash">调度算法	                        概述
轮询	          按时间顺序逐一分配到不同的后端服务器(默认)   *****
weight	          加权轮询,weight值越大,分配到的访问几率越高
ip_hash	          每个请求按访问IP的hash结果分配,来自同一IP的固定访问一个后端服务器
url_hash	      按照访问URL的hash结果来分配请求,是每个URL定向到同一个后端服务器
least_conn        最少链接数,那个机器链接数少就分发
</code></pre>
<pre><code class="language-bash">#nginx负载均衡轮询具体配置
upstream web  {
    server 10.0.0.7:80;
    server 10.0.0.8:80;
}
</code></pre>
<pre><code class="language-bash">#nginx负载均衡加权轮询具体配置
upstream web  {
        server 172.16.1.7:80 weight=5;
        server 172.16.1.8:80 weight=1;
}
</code></pre>
<pre><code class="language-bash">#nginx负载均衡ip_hash具体配置，不能和weight一起使用
upstream web  {
        ip_hash;
        server 172.16.1.7:80;
        server 172.16.1.8:80;
}
ip_hash记录在内存中，有一张对应关系表，能解决会话登录问题，但是会造成负载不均衡，导致某一台主机流
量过大，而另一台没什么流量的问题。
</code></pre>
<h2 id="nginx负载均衡后端状态">nginx负载均衡后端状态</h2>
<pre><code class="language-bash">状态		                             概述
down		                当前的server暂时不参与负载均衡
backup		                预留的备份服务器
max_fails	                允许请求失败的次数
fail_timeout                经过max_fails失败后, 服务暂停时间
max_conns	                限制最大的接收连接数
</code></pre>
<pre><code class="language-bash">#测试down状态, 该Server不参与负载均衡的调度
upstream web  {
    #不参与任何调度, 一般用于停机维护
    server 10.0.0.7:80 down;
}
</code></pre>
<pre><code class="language-bash">#测试backup状态，当所有的server不可用时，才会启用backup，这种策略很少用
upstream web  {
    server 10.0.0.7:80 backup;
    server 10.0.0.8:80;
}
location  / {
    proxy_pass http://web;
    include proxy_params;
}
</code></pre>
<pre><code class="language-bash">#测试max_fails失败次数和fail_timeout多少时间内失败多少次则标记down
upstream web  {
    server 10.0.0.7:80;
    server 10.0.0.8:80 max_fails=2 fail_timeout=10s;
}
健康检查，但无法查看到具体的指标，不够形象，除非更改源代码；
在负载均衡服务器的错误日志可以查看到后端哪台服务器处于down状态。
</code></pre>
<h2 id="nginx负载均衡健康检查">nginx负载均衡健康检查</h2>
<pre><code class="language-bash">在nginx官方提供的模块中，没有对负载均衡后端节点的健康检查模块，但可以使用第三方模块nginx_upstream_check_module
来检测后方服务的健康状态。
</code></pre>
<pre><code class="language-bash">1）安装依赖包
[root@lb01 ~]# yum install -y gcc glibc gcc-c++ pcre-devel openssl-devel patch 
</code></pre>
<pre><code class="language-bash">2）下载nginx源码包以及nginx_upstream_check第三方模块
[root@lb01 ~]# nginx -v
nginx version: nginx/1.20.1
[root@lb01 ~]# wget http://nginx.org/download/nginx-1.20.1.tar.gz
[root@lb01 ~]# wget https://github.com/yaoweibin/nginx_upstream_check_module/archive/master.zip
</code></pre>
<pre><code class="language-bash">3）解压nginx源码包以及第三方模块
[root@lb01 ~]# tar xf nginx-1.20.1.tar.gz 
[root@lb01 ~]# unzip master.zip
</code></pre>
<pre><code class="language-bash">4）进入nginx目录，打补丁
#nginx的版本是1.20，补丁就选择1.20的，p1代表在nginx目录，p0是不在nginx目录
[root@lb01 ~]# cd nginx-1.20.1/
[root@lb01 nginx-1.20.1]# patch -p1 &lt; ../nginx_upstream_check_module-master/check_1.20.1+.patch
</code></pre>
<pre><code class="language-bash">5）编译安装nginx，需要添加upstream_check第三方模块
[root@lb01 nginx-1.20.1]# ./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --add-module=/root/nginx_upstream_check_module-master --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC' --with-ld-opt='-Wl,-z,relro -Wl,-z,now -pie'
[root@lb01 nginx-1.20.1]# make &amp;&amp; make install
</code></pre>
<pre><code class="language-bash">6）配置nginx负载均衡，同时打开upstream健康检查功能
[root@lb01 ~]# cd /etc/nginx/conf.d/
[root@lb01 conf.d]# cat upstream.conf 
upstream node {
    server 172.16.1.7:80;
    server 172.16.1.8:80;
    check interval=3000 rise=2 fall=3 timeout=1000 type=tcp;
}
#interval检测间隔时间，单位为毫秒
#rsie表示请求2次正常，标记此后端的状态为up
#fall表示请求3次失败，标记此后端的状态为down
#type  类型为tcp
#timeout为超时时间，单位为毫秒
server {
    listen 80;
    server_name node.oldboy.com;

    location / {
        proxy_pass http://node;
        include proxy_params;
    }
   
    location /upstream_check {
                check_status;
    }
}
[root@lb01 conf.d]# nginx -t
[root@lb01 conf.d]# systemctl restart nginx
</code></pre>
<pre><code class="language-bash">7）通过访问域名node.oldboy.com/upstream_check则能打开状态页面
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ajie825.github.io/post-images/1659670649976.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">8）尝试关闭一台后端的webserver，再次打开检查
[root@web02 ~]# systemctl stop nginx
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ajie825.github.io/post-images/1659670947565.png" alt="" loading="lazy"></figure>
<h2 id="nginx负载均衡会话共享">nginx负载均衡会话共享</h2>
<pre><code class="language-bash">在使用负载均衡的时候会遇到会话保持的问题，可通过如下方式进行解决
1）使用nginx的ip_hash，根据客户端的来源IP，将请求分配到相同的服务器上，但会造成某一台主机压力过大
2）基于服务端的session会话共享（mysql/memcache/redis/file）
在解决负载均衡会话问题我们需要了解session和cookie。
1）用户第一次请求服务端网站时，服务端根据用户提交的信息会生成对应的session，并将session_id返回给客户端浏览器，浏
览器将session_id保存在cookie中。
2）客户端再次尝试登录服务端网站时，浏览器的请求头自动携带cookie信息，服务端会将用户提交的cookie作为key去存储里查
找对应的value(session)。
3）服务器如果没有找到session说明用户没有登录或者登录失效，如果找到Session说明用户已经登录可执行后面操作。
注意：同一域名下的网站登录后cookie都是一样的，所以无论负载后端有几台服务器，无论请求分配到哪一台服务器上，同一
用户的cookie是不会发生变化的，也就是说cookie对应的session也是唯一的，所以，这里只要保证多台服务器访问用一个共享
服务器(memcache/redis/mysql/file)就行了。
</code></pre>
<h3 id="配置示例">配置示例</h3>
<pre><code class="language-bash">1）在web01和web02上都安装phpmyadmin（最新版本为4.9.10）
[root@web01 ~]# cd /code/
[root@web01 code]# wget https://files.phpmyadmin.net/phpMyAdmin/4.8.4/phpMyAdmin-4.8.4-all-languages.zip
[root@web01 code]# unzip phpMyAdmin-4.8.4-all-languages.zip
</code></pre>
<pre><code class="language-bash">2）在web01和web02配置phpmyadmin连接远程数据库
[root@web01 code]# cd phpMyAdmin-4.8.4-all-languages/
[root@web01 phpMyAdmin-4.8.4-all-languages]# cp config.sample.inc.php config.inc.php
[root@web01 phpMyAdmin-4.8.4-all-languages]# vim config.inc.php
$cfg['Servers'][$i]['auth_type'] = 'cookie';
/* Server parameters */
$cfg['Servers'][$i]['host'] = '172.16.1.51';
$cfg['Servers'][$i]['compress'] = false;
$cfg['Servers'][$i]['AllowNoPassword'] = false;
</code></pre>
<pre><code class="language-bash">3）在web01和web02准备phpmyadmin的nginx配置文件
[root@web01 ~]# cd /etc/nginx/conf.d/
[root@web01 conf.d]# cat php.conf 
server {
        listen 80;
        server_name php.oldboy.com;
        root /code/phpMyAdmin-4.8.4-all-languages;

        location / {
                index index.php index.html;
        }

        location ~ \.php$ {
                fastcgi_pass 127.0.0.1:9000;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                include fastcgi_params;
        }
}
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">4）配置域名解析，测试访问网站
10.0.0.8 blog.oldboy.com zh.oldboy.com edu.oldboy.com php.oldboy.com
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://ajie825.github.io/post-images/1659679950260.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">5）在web01和web02配置授权
[root@web01 conf.d]# chown -R www.www /var/lib/php/
[root@web01 conf.d]# cd /var/lib/php/
[root@web01 php]# ll
total 0
drwxrwx--- 2 www www 6 Oct 26  2019 session
drwxrwx--- 2 www www 6 Oct 26  2019 wsdlcache
</code></pre>
<pre><code class="language-bash">5）测试打开网站成功
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://ajie825.github.io/post-images/1659680781241.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">6）配置负载均衡服务，调度到后端两台web节点
[root@lb01 conf.d]# cat upstream.conf 
upstream php {
    server 172.16.1.7:80;
    server 172.16.1.8:80;
}
[root@lb01 conf.d]# cat node_proxy.conf 
server {
    listen 80;
    server_name php.oldboy.com;

    location / {
       proxy_pass http://php;
        include proxy_params;
   }

}
[root@lb01 conf.d]# nginx -t
[root@lb01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">7）配置域名解析，重新进行访问网站
10.0.0.5 web.oldboy.com node.oldboy.com php.oldboy.com
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://ajie825.github.io/post-images/1659681689613.png" alt="" loading="lazy"></figure>
<h3 id="使用redis解决会话登录问题">使用redis解决会话登录问题</h3>
<pre><code class="language-bash">1）在db01服务器安装redis内存数据库
[root@db01 ~]# yum install redis -y
</code></pre>
<pre><code class="language-bash">2）配置redis监听在172.16.1.51端口
[root@db01 ~]# sed  -i '/^bind/c bind 127.0.0.1 172.16.1.51' /etc/redis.conf
</code></pre>
<pre><code class="language-bash">3）启动redis
[root@db01 ~]# systemctl enable redis
[root@db01 ~]# systemctl start redis
</code></pre>
<pre><code class="language-bash">4）php配置session连接redis
修改/etc/php.ini文件
session.save_handler = redis
session.save_path = &quot;tcp://172.16.1.51:6379&quot;
;session.save_path = &quot;tcp://172.16.1.51:6379?auth=123&quot; #如果redis存在密码，则使用该方式
session.auto_start = 1
注释php-fpm.d/www.conf里面的两条内容，否则session内容会一直写入/var/lib/php/session目录中
;php_value[session.save_handler] = files
;php_value[session.save_path]    = /var/lib/php/session
</code></pre>
<pre><code class="language-bash">5）重启php-fpm服务
[root@web01 ~]# systemctl restart php-fpm
[root@web02 ~]# systemctl restart php-fpm
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://ajie825.github.io/post-images/1659691551682.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">6）redis查看数据
[root@db01 ~]# redis-cli 
127.0.0.1:6379&gt; keys *
1) &quot;PHPREDIS_SESSION:936c958d6713fce40da751a82ddf790f&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx代理与负载均衡]]></title>
        <id>https://ajie825.github.io/post/nginx-dai-li-yu-fu-zai-jun-heng/</id>
        <link href="https://ajie825.github.io/post/nginx-dai-li-yu-fu-zai-jun-heng/">
        </link>
        <updated>2022-08-04T05:17:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nginx代理">nginx代理</h2>
<h3 id="nginx代理服务常见模式">nginx代理服务常见模式</h3>
<pre><code class="language-bash">正向代理：为防火墙内的局域网提供访问Internet途径，常用于公司内部的科学上网。
反向代理：将防火墙后面的服务器提供给Internet用户访问，为后端节点没有公网IP的主机进行代理。
</code></pre>
<p><img src="https://ajie825.github.io/post-images/1659592948466.png" alt="" loading="lazy"><br>
<img src="https://ajie825.github.io/post-images/1659592959972.png" alt="" loading="lazy"></p>
<h3 id="正向代理与反向代理的区别">正向代理与反向代理的区别</h3>
<pre><code class="language-bash">区别在于形式上服务的&quot;对象&quot;不一样
正向代理代理的对象是客户端，为客户端服务----&gt;PC电脑
反向代理代理的对象是服务端，为服务端服务----&gt;服务器
</code></pre>
<h3 id="nginx代理服务支持的协议">nginx代理服务支持的协议</h3>
<figure data-type="image" tabindex="1"><img src="https://ajie825.github.io/post-images/1659592971389.png" alt="" loading="lazy"></figure>
<h3 id="反向代理模式与nginx代理模块">反向代理模式与Nginx代理模块</h3>
<pre><code class="language-bash">反向代理模式                                       nginx配置模块
http\websocket\https\tomcat(java程序)		    ngx_http_proxy_module
fastcgi(PHP程序)				                ngx_http_fastcgi_module
uwsgi(python程序)					            ngx_http_uwsgi_module
grpc(golang程序)					            ngx_http_v2_module
</code></pre>
<h3 id="nginx反向代理配置语法">nginx反向代理配置语法</h3>
<pre><code class="language-bash">1）nginx代理配置语法
Syntax :	proxy_pass URL;
Default:	—
Context:	location, if in location, limit_except
proxy_pass  http://localhost:8000/uri/;
proxy_pass  http://192.168.56.11:8000/uri/;
proxy_pass  http://unix:/tmp/backend.socket:/uri/;
</code></pre>
<pre><code class="language-bash">2）添加发往后端服务器的请求头信息
Syntax :    proxy_set_header field value;
Default:    proxy_set_header Host $proxy_host;
            proxy_set_header Connection close;
Context:    http, server, location
#用户请求的时候host的值是www.bgx.com，那么代理服务会向后端传递请求的还是www.bgx.com
proxy_set_header Host $http_host;
#将$remote_addr的值放进变量X-Real-IP中，$remote_addr的值为客户端的ip
proxy_set_header X-Real-IP $remote_addr;
#客户端通过代理服务访问后端服务，后端服务通过该变量会记录真实客户端地址
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
</code></pre>
<pre><code class="language-bash">3）代理到后端的TCP连接、响应、返回等超时时间
#nginx代理与后端服务器连接超时时间(代理连接超时)
Syntax :    proxy_connect_timeout time;
Default:    proxy_connect_timeout 60s;
Context:    http, server, location
#nginx代理等待后端服务器的响应时间
Syntax :    proxy_read_timeout time;
Default:    proxy_read_timeout 60s;
Context:    http, server, location
#后端服务器数据回传给nginx代理超时时间
Syntax :    proxy_send_timeout time;
Default:    proxy_send_timeout 60s;
Context:    http, server, location
</code></pre>
<pre><code class="language-bash">4）proxy_buffer代理缓冲区
#nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端,边收边传, 不是全部接收完再传给客户端
Syntax : proxy_buffering on | off;
Default: proxy_buffering on;
Context: http, server, location
#设置nginx代理保存用户头信息的缓冲区大小
Syntax : proxy_buffer_size size;
Default: proxy_buffer_size 4k|8k;
Context: http, server, location
#proxy_buffers 缓冲区
Syntax : proxy_buffers number size;
Default: proxy_buffers 8 4k|8k;
Context: http, server, location
</code></pre>
<pre><code class="language-bash">5）proxy代理网站常用优化配置如下，将配置写入新文件，调用时使用include引用即可
[root@lb01 ~]# vim /etc/nginx/proxy_params
proxy_set_header Host $http_host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_connect_timeout 30;
proxy_send_timeout 60;
proxy_read_timeout 60;
proxy_buffering on;
proxy_buffer_size 32k;
proxy_buffers 4 128k;
</code></pre>
<pre><code class="language-bash">6）代理配置location时调用，方便后续多个location重复使用
location / {
    proxy_pass http://127.0.0.1:8080;
    include proxy_params;
}
</code></pre>
<h3 id="nginx反向代理场景实践">nginx反向代理场景实践</h3>
<figure data-type="image" tabindex="2"><img src="https://ajie825.github.io/post-images/1659764310714.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">1）环境准备
角色          外网IP             内网IP                主机名
proxy        10.0.0.5          172.16.1.5             lb01
web01        10.0.0.7          172.16.1.5             web01
</code></pre>
<pre><code class="language-bash">2）配置后端web01站点
[root@web01 conf.d]# cat web.oldboy.com.conf 
server {
        listen 80;
        server_name web.oldboy.com;
        root /web;

        location / {
                index index.php index.html;
        }
}
[root@web01 conf.d]# mkdir /web
[root@web01 conf.d]# echo &quot;Web01.....&quot; &gt; /web/index.html
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl restart nginx
</code></pre>
<pre><code class="language-bash">3）配置代理
[root@lb01 ~]# cd /etc/nginx/conf.d/
[root@lb01 conf.d]# cat proxy_web.conf 
server {
        listen 80;
        server_name web.oldboy.com;
        location / {
                proxy_pass http://10.0.0.7:80;
                include proxy_params;
        }
}
#proxy_params根据反向代理配置语法配置即可
[root@lb01 conf.d]# systemctl start nginx
[root@lb01 conf.d]# systemctl enable nginx
</code></pre>
<pre><code class="language-bash">4）配置域名解析
10.0.0.5 web.oldboy.com
</code></pre>
<pre><code class="language-bash">5）浏览器访问web.oldboy.com
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://ajie825.github.io/post-images/1659600222053.png" alt="" loading="lazy"></figure>
<h3 id="nginx代理局限性">nginx代理局限性</h3>
<pre><code class="language-bash">一个location仅能代理一台后端主机
</code></pre>
<pre><code class="language-bash">nginx代理生产常用配置：
location  ~ ^/user {
	proxy_pass http://10.0.0.7;
}
location  ~ ^/pass {
	proxy_pass http://10.0.0.8;
}
location  ~ ^/login {
	proxy_pass http://10.0.0.9;
}	
</code></pre>
<h2 id="nginx负载均衡">nginx负载均衡</h2>
<h3 id="为什么需要使用负载均衡">为什么需要使用负载均衡</h3>
<pre><code class="language-bash">当我们的web服务器直接面向用户，往往要承载大量并发请求，单台服务器难以负荷，使用多台web服务器组成集群，前端使用
nginx负载均衡，将请求分散的打到我们的后端服务器集群中，实现负载的分发，那么会大大提升系统的吞吐率、请求性能、高
容灾。
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://ajie825.github.io/post-images/1659602391854.png" alt="" loading="lazy"></figure>
<h3 id="常用公有云的负载均衡">常用公有云的负载均衡</h3>
<pre><code class="language-bash">SLB                         阿里云负载均衡
QLB                         青云负载均衡
CLB                         腾讯负载均衡
ULB                         ucloud的负载均衡
</code></pre>
<pre><code class="language-bash">往往我们接触的最多的是SLB(Server Load Balance)负载均衡，实现最多的也是SLB，因为SLB它的调度节点和服务节点通常
是在一个地域里面。它在这个小的逻辑地域里面决定了它对部分服务的实时性、响应性是非常好的。
所以当海量用户请求过来以后，它同样是请求调度节点，调度节点将用户的请求转发给后端对应的服务节点，服务节点处理完请
求后再转发给调度节点，调度节点最后响应给用户节点，这样也能实现一个均衡的作用。
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://ajie825.github.io/post-images/1659603180400.png" alt="" loading="lazy"></figure>
<h3 id="负载均衡能实现的应用场景">负载均衡能实现的应用场景</h3>
<pre><code class="language-bash">1）应用场景一：四层负载均衡
所谓四层负载均衡指的是OSI七层模型中的传输层，那么传输层nginx已经能支持TCP/IP的控制，所以只需要对客户端的请求
进行TCP/IP协议的包转发就可以实现负载均衡，那么它的好处是性能非常快、只需要底层进行应用处理，而不需要进行一些
复杂的逻辑。
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://ajie825.github.io/post-images/1659764562320.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-bash">2）应用场景二：七层负载均衡
七层负载均衡它是在应用层，那么它可以完成很多应用方面的协议请求，比如我们说的http应用的负载均衡，它可以实现http
信息的改写、头信息的改写、安全应用规则控制、URL匹配规则控制、以及转发、rewrite等等的规则，所以在应用层的服务里
面，我们可以做的内容就更多，那么nginx则是一个典型的七层负载均衡SLB。
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://ajie825.github.io/post-images/1659604402550.png" alt="" loading="lazy"></figure>
<h3 id="四层负载均衡与七层负载均衡区别">四层负载均衡与七层负载均衡区别</h3>
<pre><code class="language-bash">四层负载均衡数据包在底层就进行了分发，而七层负载均衡数据包则在最顶层进行分发、由此可以看出，七层负载均衡效率没
有四层负载均衡高。
但七层负载均衡更贴近于服务，如http协议就是七层协议，我们可以用nginx作会话保持、URL路径规则匹配、head头改写等
等，这些是四层负载均衡无法实现的。
</code></pre>
<h3 id="nginx负载均衡配置场景">nginx负载均衡配置场景</h3>
<pre><code class="language-bash">nginx要实现负载均衡需要用到proxy_pass代理模块配置
nginx负载均衡与nginx代理不同地方在于，nginx代理仅代理一台服务器，而nginx负载均衡则是将客户端请求代理转发一组
upstream虚拟服务池。
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://ajie825.github.io/post-images/1659605084213.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">Nginx upstream虚拟配置语法
Syntax :	upstream name { ... }
Default:	  —
Context:  http

#upstream例
upstream backend {
    server backend1.example.com weight=5;
    server backend2.example.com:8080;
    server unix:/tmp/backup3;
    server backup1.example.com:8080 backup;
}
server {
    location / {
	    proxy_pass http://backend;
	}
}
</code></pre>
<pre><code class="language-bash">1）环境规划
角色          外网(NAT)          内网(LAN)              主机名
lb01          10.0.0.5           172.16.1.5            lb01
web01         10.0.0.7           172.16.1.7            web01
web02         10.0.0.8           172.16.1.8            web02
</code></pre>
<pre><code class="language-bash">2）web01服务器上配置ngnix，并创建对应Html文件
[root@web01 conf.d]# cat node.conf 
server {
    listen 80;
    server_name node.oldboy.com;
    location / {
        root /node;
        index index.html;
    }
}
[root@web01 conf.d]# mkdir /node
[root@web01 conf.d]# echo &quot;Web01...&quot; &gt; /node/index.html
[root@web01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">3）web02服务器上配置nginx，并创建对应html文件
[root@web02 ~]# cd /etc/nginx/conf.d/
[root@web02 conf.d]# cat node.conf 
server {
    listen 80;
    server_name node.oldboy.com;
    location / {
        root /node;
        index index.html;
    }
}
[root@web02 conf.d]# mkdir /node
[root@web02 conf.d]# echo &quot;Web02...&quot; &gt; /node/index.html
[root@web02 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">4）配置nginx负载均衡
[root@lb01 conf.d]# cat node_proxy.conf 
upstream node {
    server 172.16.1.7:80;
    server 172.16.1.8:80;
}
server {
    listen 80;
    server_name node.oldboy.com;

    location / {
        proxy_pass http://node;
        include proxy_params;
    }
}
[root@lb01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">5）准备nginx负载均衡调度使用的proxy_params
[root@lb01 conf.d]# cat /etc/nginx/proxy_params 
proxy_set_header Host $http_host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_connect_timeout 30;
proxy_send_timeout 60;
proxy_read_timeout 60;
proxy_buffering on;
proxy_buffer_size 32k;
proxy_buffers 4 128k;
</code></pre>
<pre><code class="language-bash">6）重新配置负载均衡，建议将upstream写到http层，或者单独写一个upstream.conf文件----生产建议
[root@lb01 conf.d]# cat upstream.conf 
upstream node {
    server 172.16.1.7:80;
    server 172.16.1.8:80;
}
[root@lb01 conf.d]# cat node_proxy.conf 
server {
    listen 80;
    server_name node.oldboy.com;

    location / {
        proxy_pass http://node;
        include proxy_params;
    }
}
server {
    listen 80;
    server_name blog.oldboy.com;
    location / {
        proxy_pass http://node;
        include proxy_params;
    }
}

server {
    listen 80;
    server_name zh.oldboy.com;
    location / {
        proxy_pass http://node;
        include proxy_params;
    }
}
[root@lb01 conf.d]# nginx -t
[root@lb01 conf.d]# systemctl reload nginx
</code></pre>
<pre><code class="language-bash">7）配置域名解析
10.0.0.5 web.oldboy.com node.oldboy.com
</code></pre>
<pre><code class="language-bash">8）浏览器访问node.oldboy.com，然后不断刷新测试
</code></pre>
<p><img src="https://ajie825.github.io/post-images/1659664303488.png" alt="" loading="lazy"><br>
<img src="https://ajie825.github.io/post-images/1659664311634.png" alt="" loading="lazy"></p>
<pre><code class="language-bash">问题：
使用nginx负载均衡时，如何将后端请求超时的服务器流量平滑的切换到另一台服务器上？
nginx本身是有机制的，如果出现一个节点down掉的时候，nginx会根据你负载均衡的设置，将请求转移到其他的节点上，但是如
果后台服务连接没有down掉，但是返回错误异常码如504、502、500，这个时候需要加一个负载均衡的设置，如下配置：
server {
    listen 80;
    server_name oldboy.com;

    location / {
        proxy_pass http://node;
        proxy_next_upstream error timeout http_500 http_502 http_503 http_504;
    }
}
意思是，当其中一台返回错误码404、502...等错误时，可以分配到下一台服务器继续处理程序，提高平台访问成功率。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LNMP-拆分]]></title>
        <id>https://ajie825.github.io/post/lnmp-chai-fen/</id>
        <link href="https://ajie825.github.io/post/lnmp-chai-fen/">
        </link>
        <updated>2022-08-02T06:16:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="拆分数据库">拆分数据库</h2>
<h3 id="为什么进行数据库的拆分">为什么进行数据库的拆分</h3>
<pre><code class="language-bash">由于单台服务器运行LNMP架构会导致网站访问缓慢，当内存被吃满时，很容易导致系统出现oom，从而kill掉mysql数据库，所以
需要将web和数据库进行独立部署。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ajie825.github.io/post-images/1659510759022.png" alt="" loading="lazy"></figure>
<h3 id="数据库拆分后解决了什么问题">数据库拆分后解决了什么问题</h3>
<pre><code class="language-bash">1）缓解web网站的压力
2）增强数据读写性能
3）提供用户访问的速度
</code></pre>
<h3 id="数据库拆分环境规划">数据库拆分环境规划</h3>
<pre><code class="language-bash">主机名称      应用环境        外网地址        内网地址
web01        nginx+php      10.0.0.7       172.16.1.7
db01         mysql                         172.16.1.51
</code></pre>
<h3 id="数据库拆分环境实验">数据库拆分环境实验</h3>
<pre><code class="language-bash">1）备份172.16.1.7服务器上的mysql数据
[root@web01 ~]# mysqldump -uroot -p'Bgx123.com' --all-databases --single-transaction &gt; mysql-all.sql
#--single-transaction：保证数据一致性
2）传输172.16.1.7的备份数据至172.16.1.51服务器上
[root@web01 ~]# scp mysql-all.sql root@172.16.1.51:/tmp
3）在172.16.1.51服务器上安装mysql服务，然后进行还原备份
[root@db01 ~]# yum install mariadb-server mariadb -y
[root@db01 ~]# systemctl enable mariadb
[root@db01 ~]# systemctl start mariadb
[root@db01 ~]# mysql &lt; /tmp/mysql-all.sql
[root@db01 ~]# systemctl restart mariadb
[root@db01 ~]# mysql
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)
[root@db01 ~]# mysql -uroot -pBgx123.com
MariaDB [(none)]&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| edusoho            |
| mysql              |
| performance_schema |
| test               |
| wordpress          |
| zh                 |
+--------------------+
7 rows in set (0.00 sec)
</code></pre>
<pre><code class="language-bash">4）将web程序连接的本地数据库修改到远程数据库
#在172.165.1.7服务器停止mysql数据库服务
[root@web01 ~]# systemctl disable mariadb
[root@web01 ~]# systemctl stop mariadb
#在172.16.1.51服务器授权远程主机能够连接mysql数据库
[root@db01 ~]# mysql -uroot -pBgx123.com
MariaDB [(none)]&gt; grant all privileges on *.* to oldboy@'%' identified by 'Bgx123.com'; 
MariaDB [(none)]&gt; flush privileges;
#在172.16.1.7服务器测试远程账户能否连接172.16.1.51的数据库
[root@web01 ~]# yum install mariadb -y
[root@web01 ~]# mysql -h 172.16.1.51 -uoldboy -pBgx123.com
MariaDB [(none)]&gt; 
#修改172.16.1.7服务器的wordpress连接远程到172.16.1.51数据库信息
[root@web01 wordpress]# grep -R &quot;Bgx123.com&quot; *
wp-config.php:define('DB_PASSWORD', 'Bgx123.com');
[root@web01 wordpress]# cat /code/wordpress/wp-config.php
/** WordPress数据库的名称 */
define('DB_NAME', 'wordpress');
/** MySQL数据库用户名 */
define('DB_USER', 'oldboy');
/** MySQL数据库密码 */
define('DB_PASSWORD', 'Bgx123.com');
/** MySQL主机 */
define('DB_HOST', '172.16.1.51');
#修改172.16.1.7服务器的wecenter连接远程到172.16.1.51数据库信息
[root@web01 zh]# grep -R &quot;Bgx123.com&quot; *                    
system/config/database.php:  'password' =&gt; 'Bgx123.com',
[root@web01 zh]# cat system/config/database.php
$config['master'] = array (
  'charset' =&gt; 'utf8',
  'host' =&gt; '172.16.1.51',
  'username' =&gt; 'oldboy',
  'password' =&gt; 'Bgx123.com',
  'dbname' =&gt; 'zh',
#修改172.16.1.7服务器的edusoho连接远程到172.16.1.51数据库信息
[root@web01 edusoho]# grep -R &quot;Bgx123.com&quot; *
app/config/parameters.yml:    database_password: 'Bgx123.com'
[root@web01 edusoho]# cat /code/edusoho/app/config/parameters.yml
database_host: 172.16.1.51
database_port: 3306
database_name: edusoho
database_user: oldboy
database_password: 'Bgx123.com'
#必须清理缓存
[root@web01 edusoho]# rm -rf /code/edusoho/app/cache/*
</code></pre>
<h2 id="扩展多台web">扩展多台web</h2>
<h3 id="为什么要扩展多台web节点">为什么要扩展多台web节点</h3>
<pre><code class="language-bash">单台web服务器能抗住的访问量是有限的，配置多台web服务器能提升更高的访问速度。
</code></pre>
<h3 id="扩展多台web解决了什么问题">扩展多台web解决了什么问题</h3>
<pre><code class="language-bash">1）单台web节点如果故障，会导致业务宕机；
2）多台web节点能保证业务的持续稳定，扩展性高；
3）多台web节点能有效的提升用户访问网站的速度。
</code></pre>
<h3 id="扩展多台web实验">扩展多台web实验</h3>
<pre><code class="language-bash">1）统一环境（web02的IP地址为10.0.0.8）
#准备对应的www用户
[root@web02 ~]# groupadd -g666 www 
[root@web02 ~]# useradd -u666 -g666 www
#拷贝web01的yum仓库到web02
[root@web01 ~]# scp /etc/yum.repos.d/*.repo 10.0.0.8:/etc/yum.repos.d/
#web02安装nginx和php
[root@web02 ~]# yum -y install nginx php71w php71w-cli php71w-common php71w-devel php71w-embedded php71w-gd php71w-mcrypt php71w-mbstring php71w-pdo php71w-xml php71w-fpm php71w-mysqlnd php71w-opcache php71w-pecl-memcached php71w-pecl-redis php71w-pecl-mongodb
</code></pre>
<pre><code class="language-bash">2）统一配置
#同步nginx
[root@web02 ~]# rsync -avz --delete root@172.16.1.7:/etc/nginx/ /etc/nginx/
[root@web02 ~]# nginx -t
[root@web02 ~]# systemctl enable nginx
[root@web02 ~]# systemctl start nginx
#同步php（/etc/php-fpm.conf /etc/php-fpm.d  /etc/php.ini）
[root@web02 ~]# rsync  -avz --delete root@172.16.1.7:/etc/php* /etc/ 
[root@web02 ~]# systemctl enable php-fpm
[root@web02 ~]# systemctl start php-fpm
</code></pre>
<pre><code class="language-bash">3）统一代码
#在web01打包站点
[root@web01 ~]# tar zcf code.tar.gz /code
#将web01打包好的代码发送到web02
[root@web01 ~]# scp code.tar.gz root@10.0.0.8:/tmp
#web02将打包代码进行解压到/目录下
[root@web02 ~]# tar xf /tmp/code.tar.gz -C /
</code></pre>
<pre><code class="language-bash">4）配置域名解析，进行访问
#10.0.0.7 blog.oldboy.com zh.oldboy.com  edu.oldboy.com
10.0.0.8 blog.oldboy.com zh.oldboy.com edu.oldboy.com
</code></pre>
<pre><code class="language-bash">5）问题
#在web02服务器的WordPress站点中写一篇文章， web01服务器访问不到该图片
#同样在web01服务器写文章，web02服务器也访问不到web01的图片
</code></pre>
<p><img src="https://ajie825.github.io/post-images/1659578367684.png" alt="" loading="lazy"><br>
<img src="https://ajie825.github.io/post-images/1659578683334.png" alt="" loading="lazy"></p>
<h2 id="共享多台web的静态资源">共享多台web的静态资源</h2>
<h3 id="拆分静态资源至独立存储服务器">拆分静态资源至独立存储服务器</h3>
<pre><code class="language-bash">当web节点出现多台时，会导致用户上传的图片、视频附件等内容仅上传至一台web服务器，那么其他的web服务器则
无法访问到该图片。
</code></pre>
<h3 id="增加存储服务器解决了什么问题">增加存储服务器解决了什么问题</h3>
<pre><code class="language-bash">1）保证了多台web节点静态资源一致
2）有效节省多台web节点的存储空间
3）统一管理静态资源，便于后期推送至CDN进行静态资源加速
</code></pre>
<h3 id="安装nfs存储服务器">安装NFS存储服务器</h3>
<pre><code class="language-bash">#准备172.16.1.31共享存储服务器，规划目录，配置好权限
1）创建用户
[root@nfs ~]# groupadd -g666 www
[root@nfs ~]# useradd -u666 -g666 www
2）安装
[root@nfs ~]# yum install nfs-utils rpcbind -y
3）配置
[root@nfs ~]# cat /etc/exports
/data/blog 172.16.1.0/24(rw,sync,all_squash,anonuid=666,anongid=666)
/data/zh 172.16.1.0/24(rw,sync,all_squash,anonuid=666,anongid=666)
/data/edu 172.16.1.0/24(rw,sync,all_squash,anonuid=666,anongid=666)
4）根据配置创建目录，授权
[root@nfs ~]# mkdir /data/{blog,zh,edu} -p
[root@nfs ~]# chown -R www.www /data/
5）启动
[root@nfs ~]# systemctl enable rpcbind
[root@nfs ~]# systemctl enable nfs
[root@nfs ~]# systemctl start rpcbind
[root@nfs ~]# systemctl start nfs
[root@nfs ~]# showmount -e localhost
Export list for localhost:
/data/edu  172.16.1.0/24
/data/zh   172.16.1.0/24
/data/blog 172.16.1.0/24
</code></pre>
<pre><code class="language-bash">#将web02服务器的图片，推送到nfs共享存储上
http://blog.oldboy.com/wp-content/uploads/2022/08/image1.jpg
[root@web02 ~]# cd /code/wordpress/wp-content/
[root@web02 wp-content]# scp -r uploads/* root@172.16.1.31:/data/blog
#web01和web02分别安装rpcbind服务，并进行挂载
[root@web01 ~]# yum -y install nfs-utils rpcbind 
[root@web01 ~]# systemctl enable rpcbind
[root@web01 ~]# systemctl start rpcbind
[root@web01 ~]# showmount -e 172.16.1.31
Export list for 172.16.1.31:
/data/edu  172.16.1.0/24
/data/zh   172.16.1.0/24
/data/blog 172.16.1.0/24
[root@web01 ~]# mount -t nfs 172.16.1.31:/data/blog  /code/wordpress/wp-content/uploads/
[root@web01~]# cat /etc/rc.local
mount -t nfs 10.0.0.31:/data/blog  /code/wordpress/wp-content/uploads/
[root@web01 ~]# chmod +x /etc/rc.d/rc.local
</code></pre>
<pre><code class="language-bash">#此时，web01可以看到web02上传的图片
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ajie825.github.io/post-images/1659583403299.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">#在web01上重新写文章，会出现无法上传文件的错误，需要nfs服务器进行重新的递归授权
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://ajie825.github.io/post-images/1659585338596.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">[root@nfs ~]# chown -R www.www /data/
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://ajie825.github.io/post-images/1659584162388.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LNMP架构]]></title>
        <id>https://ajie825.github.io/post/lnmp-jia-gou/</id>
        <link href="https://ajie825.github.io/post/lnmp-jia-gou/">
        </link>
        <updated>2022-08-01T03:19:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="lnmp架构概述">LNMP架构概述</h2>
<h3 id="lnmp架构是如何工作的">LNMP架构是如何工作的</h3>
<pre><code class="language-bash">首先，nginx服务是不能处理动态请求的，那么当用户发起动态请求时，nginx又是如何进行处理的？
当用户发起http请求，请求会被nginx处理，如果请求是静态资源，nginx则直接返回；
如果是动态请求，nginx则通过fastcgi协议转交给后端的PHP程序处理。
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ajie825.github.io/post-images/1659324779241.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">详细说明：
1）用户通过http协议发起请求，请求会先抵达LNMP架构中的nginx
2）nginx会根据用户的请求进行location规则匹配
3）location如果匹配到请求是静态，则由nginx读取本地直接返回
4）location如果匹配到请求是动态，则由nginx将请求转发给fastcgi协议
5）fastcgi协议收到后会将请求交给php-fpm管理进程，php-fpm管理进程接收到后调用具体的工作进程wrapper
6）wrapper进程会调用php程序进行解析，如果只是解析代码，php直接返回
7）如果有查询数据库操作，则由php连接数据库（用户、密码、ip）发起查询操作
8）最终数据由mysql---&gt;php---&gt;php-fpm---&gt;fastcgi---&gt;nginx---&gt;http---&gt;user
</code></pre>
<h2 id="yum安装lnmp">YUM安装LNMP</h2>
<h3 id="使用官方仓库安装nginx">使用官方仓库安装nginx</h3>
<pre><code class="language-bash">[root@web01 ~]# cat /etc/yum.repos.d/nginx.repo 
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1

#安装Nginx
[root@web01 ~]# yum install nginx -y
</code></pre>
<h3 id="使用官方仓库安装php71">使用官方仓库安装php7.1</h3>
<pre><code class="language-bash">[root@web01 ~]# yum remove php-mysql-5.4 php php-fpm php-common
cat &gt; /etc/yum.repos.d/php.repo &lt;&lt; EOF
[php]
name = php Repository
baseurl = http://us-east.repo.webtatic.com/yum/el7/x86_64/
gpgcheck = 0
EOF

[root@web01 ~]# yum -y install php71w php71w-cli php71w-common php71w-devel php71w-embedded php71w-gd php71w-mcrypt php71w-mbstring php71w-pdo php71w-xml php71w-fpm php71w-mysqlnd php71w-opcache php71w-pecl-memcached php71w-pecl-redis php71w-pecl-mongod
</code></pre>
<h3 id="yum安装mariadb数据库">yum安装mariadb数据库</h3>
<pre><code class="language-bash">yum install mariadb-server mariadb -y
</code></pre>
<h2 id="配置nginx与php集成">配置nginx与php集成</h2>
<h3 id="fastcgi代理配置语法">fastcgi代理配置语法</h3>
<pre><code class="language-bash">#设置fastcgi服务器的地址，该地址可以指定为域名或IP地址、以及端口
Syntax :	fastcgi_pass address;
Default:	—
Context:	location, if in location
#语法示例
fastcgi_pass localhost:9000;
fastcgi_pass unix:/tmp/fastcgi.socket;

#设置fastcgi默认首页文件，需要结合fastcgi_param一起设置
Syntax :	fastcgi_index name;
Default:	—
Context:	http, server, location

#通过fastcgi_param设置变量，并将设置的变量传递到后端的fastcgi服务器
Syntax :	fastcgi_param parameter value [if_not_empty];
Default:	—
Context:	http, server, location
#语法示例
fastcgi_index index.php;
fastcgi_param SCRIPT_FILENAME /code$fastcgi_script_name;
</code></pre>
<h3 id="配置示例">配置示例</h3>
<pre><code class="language-bash">1）编写配置文件
[root@web01 ~]# cd /etc/nginx/conf.d/
[root@web01 conf.d]# cat php.conf 
server {
        listen 80;
        server_name php.oldboy.com;
        root /code;

        location / {
                index index.php index.html;
        }

        location ~ \.php$ {
                fastcgi_pass 127.0.0.1:9000;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                include fastcgi_params;
        }
}
2）根据配置文件创建目录
[root@web01 conf.d]# mkdir /code
3）配置域名解析
10.0.0.7	php.oldboy.com
4）重新加载nginx
[root@web01 conf.d]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@web01 conf.d]# systemctl reload nginx
5）启动php-fpm，并加入开机自启动
[root@web01 conf.d]# systemctl start php-fpm
[root@web01 conf.d]# systemctl enable php-fpm
6）准备一个php文件，测试nginx与php是否集成成功
[root@web01 conf.d]# cat /code/page.php 
&lt;?php
  phpinfo();
?&gt;
可以在浏览器上输入：php.oldboy.com/page.php测试
特别注意：一定要关闭selinux和firewalld防火墙  *****
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ajie825.github.io/post-images/1659333068015.png" alt="" loading="lazy"></figure>
<h2 id="配置php与mysql集成">配置php与mysql集成</h2>
<pre><code class="language-bash">1）启动数据库
[root@web01 conf.d]# systemctl enable mariadb
[root@web01 conf.d]# systemctl start mariadb
[root@web01 conf.d]# netstat -lnpt|grep mysqld
tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      2651/mysqld  
2）设置数据库的初始密码（默认mysql是空密码）
[root@web01 conf.d]# mysqladmin password 'Bgx123.com'
[root@web01 conf.d]# mysql -uroot -pBgx123.com
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 5.5.68-MariaDB MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&gt; 
3）准备一个php文件，测试能否正常连接数据库
[root@web01 conf.d]# cat /code/mysql.php 
&lt;?php
  $servername = &quot;localhost&quot;;
  $username = &quot;root&quot;;
  $password = &quot;Bgx123.com&quot;;

  // 创建连接
  $conn = mysqli_connect($servername, $username, $password);

  // 检测连接
  if (!$conn) {
      die(&quot;Connection failed: &quot; . mysqli_connect_error());
  }
  echo &quot;php连接MySQL数据库成功&quot;;
  ?&gt;
用户在浏览器中输入：http://php.oldboy.com/mysql.php 返回php连接MySQL数据库成功，说明正常连接数据库
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://ajie825.github.io/post-images/1659334544372.png" alt="" loading="lazy"></figure>
<h2 id="部署wordpress">部署wordpress</h2>
<pre><code class="language-bash">[root@web01 conf.d]# rm -rf /code/*  
1）编写nginx配置文件
[root@web01 conf.d]# cat blog.oldboy.com.conf 
server {
        listen 80;
        server_name blog.oldboy.com;
        root /code/wordpress;

        location / {
                index index.php index.html;
        }

        location ~ \.php$ {
                fastcgi_pass 127.0.0.1:9000;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                include fastcgi_params;
        }
}
2）创建站点目录并进行授权
[root@web01 conf.d]# cd /code
[root@web01 code]# wget https://cn.wordpress.org/wordpress-5.0.3-zh_CN.tar.gz
[root@web01 code]# tar xf wordpress-5.0.3-zh_CN.tar.gz 
3）创建www组和用户
[root@web01 code]# groupadd -g 666 www
[root@web01 code]# useradd -u666 -g666 www
4）修改nginx与php-fpm管理进程的运行身份为www
[root@web01 code]# sed -i '/^user /c user  www;' /etc/nginx/nginx.conf
[root@web01 code]# sed -i '/^user/c user = www' /etc/php-fpm.d/www.conf 
[root@web01 code]# sed -i '/^group/c group = www' /etc/php-fpm.d/www.conf 
5）重启nginx和php-fpm服务
[root@web01 code]# systemctl restart nginx
[root@web01 code]# systemctl restart php-fpm
6）授权代码为www组和用户
[root@web01 code]# chown -R www.www /code/wordpress
7）配置域名解析
10.0.0.7 module.oldboy.com blog.oldboy.com
8）浏览器输入blog.oldboy.com就可以安装wordpress搭建博客了
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://ajie825.github.io/post-images/1659336501392.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">9）创建一个wordpress的库
[root@web01 ~]# mysql -uroot -pBgx123.com
MariaDB [(none)]&gt; create database wordpress;
Query OK, 1 row affected (0.00 sec)

MariaDB [(none)]&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
| wordpress          |
+--------------------+
5 rows in set (0.00 sec)
</code></pre>
<p><img src="https://ajie825.github.io/post-images/1659490155950.png" alt="" loading="lazy"><br>
<img src="https://ajie825.github.io/post-images/1659337398034.png" alt="" loading="lazy"></p>
<pre><code class="language-bash">10）点击外观-添加-上传主题-选择文件-上传  发现会报413 Request Entity Too Large
原因是nginx对上传的文件大小做了限制
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://ajie825.github.io/post-images/1659338102432.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">10）解决nginx上传文件大小限制
[root@web01 conf.d]# cat blog.oldboy.com.conf 
server {
        listen 80;
        server_name blog.oldboy.com;
        root /code/wordpress;
        client_max_body_size 100m;

        location / {
                index index.php index.html;
        }

        location ~ \.php$ {
                fastcgi_pass 127.0.0.1:9000;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                include fastcgi_params;
        }
}
[root@web01 conf.d]# systemctl reload nginx 
#client_max_body_size 100m   默认nginx仅支持上传1m大小的文件
继续上传主题---&gt;启用
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://ajie825.github.io/post-images/1659404289253.png" alt="" loading="lazy"></figure>
<h2 id="部署wecenter知乎">部署wecenter知乎</h2>
<pre><code class="language-bash">1）编写nginx配置文件
[root@web01 conf.d]# cat zh.oldboy.com.conf 
server {
        listen 80;
        server_name zh.oldboy.com;
        root /code/zh;
        client_max_body_size 100m;

        location / {
                index index.php index.html;
        }

        location ~ \.php$ {
                fastcgi_pass 127.0.0.1:9000;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                include fastcgi_params;
        }
}
2）检查配置文件并重启nginx服务
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl reload nginx
3）上传软件到站点目录并授权
[root@web01 code]# rz -E WeCenter_3-2-1.zip
[root@web01 code]# unzip WeCenter_3-2-1.zip
[root@web01 code]# mv WeCenter_3-2-1 zh
[root@web01 code]# chown -R www.www zh/
4）配置域名解析
10.0.0.7 zh.oldboy.com
5）在浏览器中输入zh.oldboy.com进行访问
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://ajie825.github.io/post-images/1659409568268.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">6）配置数据库
[root@web01 code]# mysql -uroot -pBgx123.com
MariaDB [(none)]&gt; create database zh;
MariaDB [(none)]&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
| wordpress          |
| zh                 |
+--------------------+
6 rows in set (0.00 sec)
</code></pre>
<p><img src="https://ajie825.github.io/post-images/1659491267982.png" alt="" loading="lazy"><br>
<img src="https://ajie825.github.io/post-images/1659412255955.png" alt="" loading="lazy"></p>
<h2 id="部署edusoho">部署edusoho</h2>
<pre><code class="language-bash">1）编写nginx配置文件
[root@web01 conf.d]# cat edu.oldboy.com.conf 
server {
    listen 80;
    server_name edu.oldboy.com;
    root /code/edusoho/web;
    client_max_body_size 200m;

    location / {
        index app.php;
        try_files $uri @rewriteapp;
    }
    location @rewriteapp {
        rewrite ^(.*)$ /app.php/$1 last;
    }

    location ~ ^/udisk {
        internal;
        root /code/edusoho/app/data/;
    }

    location ~ ^/(app|app_dev)\.php(/|$) {
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;
        fastcgi_param  HTTPS              off;
        fastcgi_param HTTP_X-Sendfile-Type X-Accel-Redirect;
        fastcgi_param HTTP_X-Accel-Mapping /udisk=/code/edusoho/app/data/udisk;
        fastcgi_buffer_size 128k;
        fastcgi_buffers 8 128k;
    }
    # 配置设置图片格式文件
    location ~* \.(jpg|jpeg|gif|png|ico|swf)$ {
        # 过期时间为3年
        expires 3y;
        # 关闭日志记录
        access_log off;
        # 关闭gzip压缩，减少CPU消耗，因为图片的压缩率不高。
        gzip off;
    }
    # 配置css/js文件
    location ~* \.(css|js)$ {
        access_log off;
        expires 3y;
    }
    # 禁止用户上传目录下所有.php文件的访问，提高安全性
    location ~ ^/files/.*\.(php|php5)$ {
        deny all;
    }
    # 以下配置允许运行.php的程序，方便于其他第三方系统的集成。
    location ~ \.php$ {
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;
        fastcgi_param  HTTPS              off;
    }
}
2）检查配置文件并重启nginx服务
[root@web01 conf.d]# nginx -t
[root@web01 conf.d]# systemctl reload nginx
3）下载软件并授权
[root@web01 code]# wget http://download.edusoho.com/edusoho-8.2.17.tar.gz
[root@web01 code]# tar xf edusoho-8.2.17.tar.gz
[root@web01 code]# chown -R www.www edusoho
4）配置域名解析
10.0.0.7 edu.oldboy.com
5）在浏览器输入edu.oldboy.com进行访问
</code></pre>
<p><img src="https://ajie825.github.io/post-images/1659417659694.png" alt="" loading="lazy"><br>
<img src="https://ajie825.github.io/post-images/1659417761128.png" alt="" loading="lazy"><br>
<img src="https://ajie825.github.io/post-images/1659417932048.png" alt="" loading="lazy"><br>
<img src="https://ajie825.github.io/post-images/1659418008129.png" alt="" loading="lazy"><br>
<img src="https://ajie825.github.io/post-images/1659418127524.png" alt="" loading="lazy"><br>
<img src="https://ajie825.github.io/post-images/1659418761459.png" alt="" loading="lazy"></p>
<pre><code class="language-bash">6）调整php的上传大小
[root@web01 ~]# vim /etc/php.ini
post_max_size = 200M
upload_max_filesize = 200M
[root@web01 code]# systemctl restart php-fpm
#注：测试谷歌浏览器无法上传，选择火狐浏览器即可！
</code></pre>
]]></content>
    </entry>
</feed>